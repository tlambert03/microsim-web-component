(function(){"use strict";try{if(typeof document<"u"){var o=document.createElement("style");o.appendChild(document.createTextNode(':where(:root),:host{--wa-color-red-gte-60: calc(100% - (clamp(0, 60 - var(--wa-color-red-key), 1)*100%)) ;--wa-color-orange-gte-60: calc(100% - (clamp(0, 60 - var(--wa-color-orange-key), 1)*100%)) ;--wa-color-yellow-gte-60: calc(100% - (clamp(0, 60 - var(--wa-color-yellow-key), 1)*100%)) ;--wa-color-green-gte-60: calc(100% - (clamp(0, 60 - var(--wa-color-green-key), 1)*100%)) ;--wa-color-cyan-gte-60: calc(100% - (clamp(0, 60 - var(--wa-color-cyan-key), 1)*100%)) ;--wa-color-blue-gte-60: calc(100% - (clamp(0, 60 - var(--wa-color-blue-key), 1)*100%)) ;--wa-color-indigo-gte-60: calc(100% - (clamp(0, 60 - var(--wa-color-indigo-key), 1)*100%)) ;--wa-color-purple-gte-60: calc(100% - (clamp(0, 60 - var(--wa-color-purple-key), 1)*100%)) ;--wa-color-pink-gte-60: calc(100% - (clamp(0, 60 - var(--wa-color-pink-key), 1)*100%)) ;--wa-color-gray-gte-60: calc(100% - (clamp(0, 60 - var(--wa-color-gray-key), 1)*100%)) ;--wa-color-red-on: color-mix(in oklab, var(--wa-color-red-10) var(--wa-color-red-gte-60), white);--wa-color-orange-on: color-mix(in oklab, var(--wa-color-orange-10) var(--wa-color-orange-gte-60), white);--wa-color-yellow-on: color-mix(in oklab, var(--wa-color-yellow-10) var(--wa-color-yellow-gte-60), white);--wa-color-green-on: color-mix(in oklab, var(--wa-color-green-10) var(--wa-color-green-gte-60), white);--wa-color-cyan-on: color-mix(in oklab, var(--wa-color-cyan-10) var(--wa-color-cyan-gte-60), white);--wa-color-blue-on: color-mix(in oklab, var(--wa-color-blue-10) var(--wa-color-blue-gte-60), white);--wa-color-indigo-on: color-mix(in oklab, var(--wa-color-indigo-10) var(--wa-color-indigo-gte-60), white);--wa-color-purple-on: color-mix(in oklab, var(--wa-color-purple-10) var(--wa-color-purple-gte-60), white);--wa-color-pink-on: color-mix(in oklab, var(--wa-color-pink-10) var(--wa-color-pink-gte-60), white);--wa-color-gray-on: color-mix(in oklab, var(--wa-color-gray-10) var(--wa-color-gray-gte-60), white)}@layer wa-color-variant{:where(:root),.wa-brand-blue{--wa-color-brand-95: var(--wa-color-blue-95);--wa-color-brand-90: var(--wa-color-blue-90);--wa-color-brand-80: var(--wa-color-blue-80);--wa-color-brand-70: var(--wa-color-blue-70);--wa-color-brand-60: var(--wa-color-blue-60);--wa-color-brand-50: var(--wa-color-blue-50);--wa-color-brand-40: var(--wa-color-blue-40);--wa-color-brand-30: var(--wa-color-blue-30);--wa-color-brand-20: var(--wa-color-blue-20);--wa-color-brand-10: var(--wa-color-blue-10);--wa-color-brand-05: var(--wa-color-blue-05);--wa-color-brand: var(--wa-color-blue);--wa-color-brand-on: var(--wa-color-blue-on)}.wa-brand-red{--wa-color-brand-95: var(--wa-color-red-95);--wa-color-brand-90: var(--wa-color-red-90);--wa-color-brand-80: var(--wa-color-red-80);--wa-color-brand-70: var(--wa-color-red-70);--wa-color-brand-60: var(--wa-color-red-60);--wa-color-brand-50: var(--wa-color-red-50);--wa-color-brand-40: var(--wa-color-red-40);--wa-color-brand-30: var(--wa-color-red-30);--wa-color-brand-20: var(--wa-color-red-20);--wa-color-brand-10: var(--wa-color-red-10);--wa-color-brand-05: var(--wa-color-red-05);--wa-color-brand: var(--wa-color-red);--wa-color-brand-on: var(--wa-color-red-on)}.wa-brand-orange{--wa-color-brand-95: var(--wa-color-orange-95);--wa-color-brand-90: var(--wa-color-orange-90);--wa-color-brand-80: var(--wa-color-orange-80);--wa-color-brand-70: var(--wa-color-orange-70);--wa-color-brand-60: var(--wa-color-orange-60);--wa-color-brand-50: var(--wa-color-orange-50);--wa-color-brand-40: var(--wa-color-orange-40);--wa-color-brand-30: var(--wa-color-orange-30);--wa-color-brand-20: var(--wa-color-orange-20);--wa-color-brand-10: var(--wa-color-orange-10);--wa-color-brand-05: var(--wa-color-orange-05);--wa-color-brand: var(--wa-color-orange);--wa-color-brand-on: var(--wa-color-orange-on)}.wa-brand-yellow{--wa-color-brand-95: var(--wa-color-yellow-95);--wa-color-brand-90: var(--wa-color-yellow-90);--wa-color-brand-80: var(--wa-color-yellow-80);--wa-color-brand-70: var(--wa-color-yellow-70);--wa-color-brand-60: var(--wa-color-yellow-60);--wa-color-brand-50: var(--wa-color-yellow-50);--wa-color-brand-40: var(--wa-color-yellow-40);--wa-color-brand-30: var(--wa-color-yellow-30);--wa-color-brand-20: var(--wa-color-yellow-20);--wa-color-brand-10: var(--wa-color-yellow-10);--wa-color-brand-05: var(--wa-color-yellow-05);--wa-color-brand: var(--wa-color-yellow);--wa-color-brand-on: var(--wa-color-yellow-on)}.wa-brand-green{--wa-color-brand-95: var(--wa-color-green-95);--wa-color-brand-90: var(--wa-color-green-90);--wa-color-brand-80: var(--wa-color-green-80);--wa-color-brand-70: var(--wa-color-green-70);--wa-color-brand-60: var(--wa-color-green-60);--wa-color-brand-50: var(--wa-color-green-50);--wa-color-brand-40: var(--wa-color-green-40);--wa-color-brand-30: var(--wa-color-green-30);--wa-color-brand-20: var(--wa-color-green-20);--wa-color-brand-10: var(--wa-color-green-10);--wa-color-brand-05: var(--wa-color-green-05);--wa-color-brand: var(--wa-color-green);--wa-color-brand-on: var(--wa-color-green-on)}.wa-brand-cyan{--wa-color-brand-95: var(--wa-color-cyan-95);--wa-color-brand-90: var(--wa-color-cyan-90);--wa-color-brand-80: var(--wa-color-cyan-80);--wa-color-brand-70: var(--wa-color-cyan-70);--wa-color-brand-60: var(--wa-color-cyan-60);--wa-color-brand-50: var(--wa-color-cyan-50);--wa-color-brand-40: var(--wa-color-cyan-40);--wa-color-brand-30: var(--wa-color-cyan-30);--wa-color-brand-20: var(--wa-color-cyan-20);--wa-color-brand-10: var(--wa-color-cyan-10);--wa-color-brand-05: var(--wa-color-cyan-05);--wa-color-brand: var(--wa-color-cyan);--wa-color-brand-on: var(--wa-color-cyan-on)}.wa-brand-indigo{--wa-color-brand-95: var(--wa-color-indigo-95);--wa-color-brand-90: var(--wa-color-indigo-90);--wa-color-brand-80: var(--wa-color-indigo-80);--wa-color-brand-70: var(--wa-color-indigo-70);--wa-color-brand-60: var(--wa-color-indigo-60);--wa-color-brand-50: var(--wa-color-indigo-50);--wa-color-brand-40: var(--wa-color-indigo-40);--wa-color-brand-30: var(--wa-color-indigo-30);--wa-color-brand-20: var(--wa-color-indigo-20);--wa-color-brand-10: var(--wa-color-indigo-10);--wa-color-brand-05: var(--wa-color-indigo-05);--wa-color-brand: var(--wa-color-indigo);--wa-color-brand-on: var(--wa-color-indigo-on)}.wa-brand-purple{--wa-color-brand-95: var(--wa-color-purple-95);--wa-color-brand-90: var(--wa-color-purple-90);--wa-color-brand-80: var(--wa-color-purple-80);--wa-color-brand-70: var(--wa-color-purple-70);--wa-color-brand-60: var(--wa-color-purple-60);--wa-color-brand-50: var(--wa-color-purple-50);--wa-color-brand-40: var(--wa-color-purple-40);--wa-color-brand-30: var(--wa-color-purple-30);--wa-color-brand-20: var(--wa-color-purple-20);--wa-color-brand-10: var(--wa-color-purple-10);--wa-color-brand-05: var(--wa-color-purple-05);--wa-color-brand: var(--wa-color-purple);--wa-color-brand-on: var(--wa-color-purple-on)}.wa-brand-pink{--wa-color-brand-95: var(--wa-color-pink-95);--wa-color-brand-90: var(--wa-color-pink-90);--wa-color-brand-80: var(--wa-color-pink-80);--wa-color-brand-70: var(--wa-color-pink-70);--wa-color-brand-60: var(--wa-color-pink-60);--wa-color-brand-50: var(--wa-color-pink-50);--wa-color-brand-40: var(--wa-color-pink-40);--wa-color-brand-30: var(--wa-color-pink-30);--wa-color-brand-20: var(--wa-color-pink-20);--wa-color-brand-10: var(--wa-color-pink-10);--wa-color-brand-05: var(--wa-color-pink-05);--wa-color-brand: var(--wa-color-pink);--wa-color-brand-on: var(--wa-color-pink-on)}.wa-brand-gray{--wa-color-brand-95: var(--wa-color-gray-95);--wa-color-brand-90: var(--wa-color-gray-90);--wa-color-brand-80: var(--wa-color-gray-80);--wa-color-brand-70: var(--wa-color-gray-70);--wa-color-brand-60: var(--wa-color-gray-60);--wa-color-brand-50: var(--wa-color-gray-50);--wa-color-brand-40: var(--wa-color-gray-40);--wa-color-brand-30: var(--wa-color-gray-30);--wa-color-brand-20: var(--wa-color-gray-20);--wa-color-brand-10: var(--wa-color-gray-10);--wa-color-brand-05: var(--wa-color-gray-05);--wa-color-brand: var(--wa-color-gray);--wa-color-brand-on: var(--wa-color-gray-on)}}@layer wa-color-variant{:where(:root),.wa-neutral-gray{--wa-color-neutral-95: var(--wa-color-gray-95);--wa-color-neutral-90: var(--wa-color-gray-90);--wa-color-neutral-80: var(--wa-color-gray-80);--wa-color-neutral-70: var(--wa-color-gray-70);--wa-color-neutral-60: var(--wa-color-gray-60);--wa-color-neutral-50: var(--wa-color-gray-50);--wa-color-neutral-40: var(--wa-color-gray-40);--wa-color-neutral-30: var(--wa-color-gray-30);--wa-color-neutral-20: var(--wa-color-gray-20);--wa-color-neutral-10: var(--wa-color-gray-10);--wa-color-neutral-05: var(--wa-color-gray-05);--wa-color-neutral: var(--wa-color-gray);--wa-color-neutral-on: var(--wa-color-gray-on)}.wa-neutral-red{--wa-color-neutral-95: var(--wa-color-red-95);--wa-color-neutral-90: var(--wa-color-red-90);--wa-color-neutral-80: var(--wa-color-red-80);--wa-color-neutral-70: var(--wa-color-red-70);--wa-color-neutral-60: var(--wa-color-red-60);--wa-color-neutral-50: var(--wa-color-red-50);--wa-color-neutral-40: var(--wa-color-red-40);--wa-color-neutral-30: var(--wa-color-red-30);--wa-color-neutral-20: var(--wa-color-red-20);--wa-color-neutral-10: var(--wa-color-red-10);--wa-color-neutral-05: var(--wa-color-red-05);--wa-color-neutral: var(--wa-color-red);--wa-color-neutral-on: var(--wa-color-red-on)}.wa-neutral-orange{--wa-color-neutral-95: var(--wa-color-orange-95);--wa-color-neutral-90: var(--wa-color-orange-90);--wa-color-neutral-80: var(--wa-color-orange-80);--wa-color-neutral-70: var(--wa-color-orange-70);--wa-color-neutral-60: var(--wa-color-orange-60);--wa-color-neutral-50: var(--wa-color-orange-50);--wa-color-neutral-40: var(--wa-color-orange-40);--wa-color-neutral-30: var(--wa-color-orange-30);--wa-color-neutral-20: var(--wa-color-orange-20);--wa-color-neutral-10: var(--wa-color-orange-10);--wa-color-neutral-05: var(--wa-color-orange-05);--wa-color-neutral: var(--wa-color-orange);--wa-color-neutral-on: var(--wa-color-orange-on)}.wa-neutral-yellow{--wa-color-neutral-95: var(--wa-color-yellow-95);--wa-color-neutral-90: var(--wa-color-yellow-90);--wa-color-neutral-80: var(--wa-color-yellow-80);--wa-color-neutral-70: var(--wa-color-yellow-70);--wa-color-neutral-60: var(--wa-color-yellow-60);--wa-color-neutral-50: var(--wa-color-yellow-50);--wa-color-neutral-40: var(--wa-color-yellow-40);--wa-color-neutral-30: var(--wa-color-yellow-30);--wa-color-neutral-20: var(--wa-color-yellow-20);--wa-color-neutral-10: var(--wa-color-yellow-10);--wa-color-neutral-05: var(--wa-color-yellow-05);--wa-color-neutral: var(--wa-color-yellow);--wa-color-neutral-on: var(--wa-color-yellow-on)}.wa-neutral-green{--wa-color-neutral-95: var(--wa-color-green-95);--wa-color-neutral-90: var(--wa-color-green-90);--wa-color-neutral-80: var(--wa-color-green-80);--wa-color-neutral-70: var(--wa-color-green-70);--wa-color-neutral-60: var(--wa-color-green-60);--wa-color-neutral-50: var(--wa-color-green-50);--wa-color-neutral-40: var(--wa-color-green-40);--wa-color-neutral-30: var(--wa-color-green-30);--wa-color-neutral-20: var(--wa-color-green-20);--wa-color-neutral-10: var(--wa-color-green-10);--wa-color-neutral-05: var(--wa-color-green-05);--wa-color-neutral: var(--wa-color-green);--wa-color-neutral-on: var(--wa-color-green-on)}.wa-neutral-cyan{--wa-color-neutral-95: var(--wa-color-cyan-95);--wa-color-neutral-90: var(--wa-color-cyan-90);--wa-color-neutral-80: var(--wa-color-cyan-80);--wa-color-neutral-70: var(--wa-color-cyan-70);--wa-color-neutral-60: var(--wa-color-cyan-60);--wa-color-neutral-50: var(--wa-color-cyan-50);--wa-color-neutral-40: var(--wa-color-cyan-40);--wa-color-neutral-30: var(--wa-color-cyan-30);--wa-color-neutral-20: var(--wa-color-cyan-20);--wa-color-neutral-10: var(--wa-color-cyan-10);--wa-color-neutral-05: var(--wa-color-cyan-05);--wa-color-neutral: var(--wa-color-cyan);--wa-color-neutral-on: var(--wa-color-cyan-on)}.wa-neutral-blue{--wa-color-neutral-95: var(--wa-color-blue-95);--wa-color-neutral-90: var(--wa-color-blue-90);--wa-color-neutral-80: var(--wa-color-blue-80);--wa-color-neutral-70: var(--wa-color-blue-70);--wa-color-neutral-60: var(--wa-color-blue-60);--wa-color-neutral-50: var(--wa-color-blue-50);--wa-color-neutral-40: var(--wa-color-blue-40);--wa-color-neutral-30: var(--wa-color-blue-30);--wa-color-neutral-20: var(--wa-color-blue-20);--wa-color-neutral-10: var(--wa-color-blue-10);--wa-color-neutral-05: var(--wa-color-blue-05);--wa-color-neutral: var(--wa-color-blue);--wa-color-neutral-on: var(--wa-color-blue-on)}.wa-neutral-indigo{--wa-color-neutral-95: var(--wa-color-indigo-95);--wa-color-neutral-90: var(--wa-color-indigo-90);--wa-color-neutral-80: var(--wa-color-indigo-80);--wa-color-neutral-70: var(--wa-color-indigo-70);--wa-color-neutral-60: var(--wa-color-indigo-60);--wa-color-neutral-50: var(--wa-color-indigo-50);--wa-color-neutral-40: var(--wa-color-indigo-40);--wa-color-neutral-30: var(--wa-color-indigo-30);--wa-color-neutral-20: var(--wa-color-indigo-20);--wa-color-neutral-10: var(--wa-color-indigo-10);--wa-color-neutral-05: var(--wa-color-indigo-05);--wa-color-neutral: var(--wa-color-indigo);--wa-color-neutral-on: var(--wa-color-indigo-on)}.wa-neutral-purple{--wa-color-neutral-95: var(--wa-color-purple-95);--wa-color-neutral-90: var(--wa-color-purple-90);--wa-color-neutral-80: var(--wa-color-purple-80);--wa-color-neutral-70: var(--wa-color-purple-70);--wa-color-neutral-60: var(--wa-color-purple-60);--wa-color-neutral-50: var(--wa-color-purple-50);--wa-color-neutral-40: var(--wa-color-purple-40);--wa-color-neutral-30: var(--wa-color-purple-30);--wa-color-neutral-20: var(--wa-color-purple-20);--wa-color-neutral-10: var(--wa-color-purple-10);--wa-color-neutral-05: var(--wa-color-purple-05);--wa-color-neutral: var(--wa-color-purple);--wa-color-neutral-on: var(--wa-color-purple-on)}.wa-neutral-pink{--wa-color-neutral-95: var(--wa-color-pink-95);--wa-color-neutral-90: var(--wa-color-pink-90);--wa-color-neutral-80: var(--wa-color-pink-80);--wa-color-neutral-70: var(--wa-color-pink-70);--wa-color-neutral-60: var(--wa-color-pink-60);--wa-color-neutral-50: var(--wa-color-pink-50);--wa-color-neutral-40: var(--wa-color-pink-40);--wa-color-neutral-30: var(--wa-color-pink-30);--wa-color-neutral-20: var(--wa-color-pink-20);--wa-color-neutral-10: var(--wa-color-pink-10);--wa-color-neutral-05: var(--wa-color-pink-05);--wa-color-neutral: var(--wa-color-pink);--wa-color-neutral-on: var(--wa-color-pink-on)}}@layer wa-color-variant{:where(:root),.wa-success-green{--wa-color-success-95: var(--wa-color-green-95);--wa-color-success-90: var(--wa-color-green-90);--wa-color-success-80: var(--wa-color-green-80);--wa-color-success-70: var(--wa-color-green-70);--wa-color-success-60: var(--wa-color-green-60);--wa-color-success-50: var(--wa-color-green-50);--wa-color-success-40: var(--wa-color-green-40);--wa-color-success-30: var(--wa-color-green-30);--wa-color-success-20: var(--wa-color-green-20);--wa-color-success-10: var(--wa-color-green-10);--wa-color-success-05: var(--wa-color-green-05);--wa-color-success: var(--wa-color-green);--wa-color-success-on: var(--wa-color-green-on)}.wa-success-red{--wa-color-success-95: var(--wa-color-red-95);--wa-color-success-90: var(--wa-color-red-90);--wa-color-success-80: var(--wa-color-red-80);--wa-color-success-70: var(--wa-color-red-70);--wa-color-success-60: var(--wa-color-red-60);--wa-color-success-50: var(--wa-color-red-50);--wa-color-success-40: var(--wa-color-red-40);--wa-color-success-30: var(--wa-color-red-30);--wa-color-success-20: var(--wa-color-red-20);--wa-color-success-10: var(--wa-color-red-10);--wa-color-success-05: var(--wa-color-red-05);--wa-color-success: var(--wa-color-red);--wa-color-success-on: var(--wa-color-red-on)}.wa-success-orange{--wa-color-success-95: var(--wa-color-orange-95);--wa-color-success-90: var(--wa-color-orange-90);--wa-color-success-80: var(--wa-color-orange-80);--wa-color-success-70: var(--wa-color-orange-70);--wa-color-success-60: var(--wa-color-orange-60);--wa-color-success-50: var(--wa-color-orange-50);--wa-color-success-40: var(--wa-color-orange-40);--wa-color-success-30: var(--wa-color-orange-30);--wa-color-success-20: var(--wa-color-orange-20);--wa-color-success-10: var(--wa-color-orange-10);--wa-color-success-05: var(--wa-color-orange-05);--wa-color-success: var(--wa-color-orange);--wa-color-success-on: var(--wa-color-orange-on)}.wa-success-yellow{--wa-color-success-95: var(--wa-color-yellow-95);--wa-color-success-90: var(--wa-color-yellow-90);--wa-color-success-80: var(--wa-color-yellow-80);--wa-color-success-70: var(--wa-color-yellow-70);--wa-color-success-60: var(--wa-color-yellow-60);--wa-color-success-50: var(--wa-color-yellow-50);--wa-color-success-40: var(--wa-color-yellow-40);--wa-color-success-30: var(--wa-color-yellow-30);--wa-color-success-20: var(--wa-color-yellow-20);--wa-color-success-10: var(--wa-color-yellow-10);--wa-color-success-05: var(--wa-color-yellow-05);--wa-color-success: var(--wa-color-yellow);--wa-color-success-on: var(--wa-color-yellow-on)}.wa-success-cyan{--wa-color-success-95: var(--wa-color-cyan-95);--wa-color-success-90: var(--wa-color-cyan-90);--wa-color-success-80: var(--wa-color-cyan-80);--wa-color-success-70: var(--wa-color-cyan-70);--wa-color-success-60: var(--wa-color-cyan-60);--wa-color-success-50: var(--wa-color-cyan-50);--wa-color-success-40: var(--wa-color-cyan-40);--wa-color-success-30: var(--wa-color-cyan-30);--wa-color-success-20: var(--wa-color-cyan-20);--wa-color-success-10: var(--wa-color-cyan-10);--wa-color-success-05: var(--wa-color-cyan-05);--wa-color-success: var(--wa-color-cyan);--wa-color-success-on: var(--wa-color-cyan-on)}.wa-success-blue{--wa-color-success-95: var(--wa-color-blue-95);--wa-color-success-90: var(--wa-color-blue-90);--wa-color-success-80: var(--wa-color-blue-80);--wa-color-success-70: var(--wa-color-blue-70);--wa-color-success-60: var(--wa-color-blue-60);--wa-color-success-50: var(--wa-color-blue-50);--wa-color-success-40: var(--wa-color-blue-40);--wa-color-success-30: var(--wa-color-blue-30);--wa-color-success-20: var(--wa-color-blue-20);--wa-color-success-10: var(--wa-color-blue-10);--wa-color-success-05: var(--wa-color-blue-05);--wa-color-success: var(--wa-color-blue);--wa-color-success-on: var(--wa-color-blue-on)}.wa-success-indigo{--wa-color-success-95: var(--wa-color-indigo-95);--wa-color-success-90: var(--wa-color-indigo-90);--wa-color-success-80: var(--wa-color-indigo-80);--wa-color-success-70: var(--wa-color-indigo-70);--wa-color-success-60: var(--wa-color-indigo-60);--wa-color-success-50: var(--wa-color-indigo-50);--wa-color-success-40: var(--wa-color-indigo-40);--wa-color-success-30: var(--wa-color-indigo-30);--wa-color-success-20: var(--wa-color-indigo-20);--wa-color-success-10: var(--wa-color-indigo-10);--wa-color-success-05: var(--wa-color-indigo-05);--wa-color-success: var(--wa-color-indigo);--wa-color-success-on: var(--wa-color-indigo-on)}.wa-success-purple{--wa-color-success-95: var(--wa-color-purple-95);--wa-color-success-90: var(--wa-color-purple-90);--wa-color-success-80: var(--wa-color-purple-80);--wa-color-success-70: var(--wa-color-purple-70);--wa-color-success-60: var(--wa-color-purple-60);--wa-color-success-50: var(--wa-color-purple-50);--wa-color-success-40: var(--wa-color-purple-40);--wa-color-success-30: var(--wa-color-purple-30);--wa-color-success-20: var(--wa-color-purple-20);--wa-color-success-10: var(--wa-color-purple-10);--wa-color-success-05: var(--wa-color-purple-05);--wa-color-success: var(--wa-color-purple);--wa-color-success-on: var(--wa-color-purple-on)}.wa-success-pink{--wa-color-success-95: var(--wa-color-pink-95);--wa-color-success-90: var(--wa-color-pink-90);--wa-color-success-80: var(--wa-color-pink-80);--wa-color-success-70: var(--wa-color-pink-70);--wa-color-success-60: var(--wa-color-pink-60);--wa-color-success-50: var(--wa-color-pink-50);--wa-color-success-40: var(--wa-color-pink-40);--wa-color-success-30: var(--wa-color-pink-30);--wa-color-success-20: var(--wa-color-pink-20);--wa-color-success-10: var(--wa-color-pink-10);--wa-color-success-05: var(--wa-color-pink-05);--wa-color-success: var(--wa-color-pink);--wa-color-success-on: var(--wa-color-pink-on)}.wa-success-gray{--wa-color-success-95: var(--wa-color-gray-95);--wa-color-success-90: var(--wa-color-gray-90);--wa-color-success-80: var(--wa-color-gray-80);--wa-color-success-70: var(--wa-color-gray-70);--wa-color-success-60: var(--wa-color-gray-60);--wa-color-success-50: var(--wa-color-gray-50);--wa-color-success-40: var(--wa-color-gray-40);--wa-color-success-30: var(--wa-color-gray-30);--wa-color-success-20: var(--wa-color-gray-20);--wa-color-success-10: var(--wa-color-gray-10);--wa-color-success-05: var(--wa-color-gray-05);--wa-color-success: var(--wa-color-gray);--wa-color-success-on: var(--wa-color-gray-on)}}@layer wa-color-variant{:where(:root),.wa-warning-yellow{--wa-color-warning-95: var(--wa-color-yellow-95);--wa-color-warning-90: var(--wa-color-yellow-90);--wa-color-warning-80: var(--wa-color-yellow-80);--wa-color-warning-70: var(--wa-color-yellow-70);--wa-color-warning-60: var(--wa-color-yellow-60);--wa-color-warning-50: var(--wa-color-yellow-50);--wa-color-warning-40: var(--wa-color-yellow-40);--wa-color-warning-30: var(--wa-color-yellow-30);--wa-color-warning-20: var(--wa-color-yellow-20);--wa-color-warning-10: var(--wa-color-yellow-10);--wa-color-warning-05: var(--wa-color-yellow-05);--wa-color-warning: var(--wa-color-yellow);--wa-color-warning-on: var(--wa-color-yellow-on)}.wa-warning-red{--wa-color-warning-95: var(--wa-color-red-95);--wa-color-warning-90: var(--wa-color-red-90);--wa-color-warning-80: var(--wa-color-red-80);--wa-color-warning-70: var(--wa-color-red-70);--wa-color-warning-60: var(--wa-color-red-60);--wa-color-warning-50: var(--wa-color-red-50);--wa-color-warning-40: var(--wa-color-red-40);--wa-color-warning-30: var(--wa-color-red-30);--wa-color-warning-20: var(--wa-color-red-20);--wa-color-warning-10: var(--wa-color-red-10);--wa-color-warning-05: var(--wa-color-red-05);--wa-color-warning: var(--wa-color-red);--wa-color-warning-on: var(--wa-color-red-on)}.wa-warning-orange{--wa-color-warning-95: var(--wa-color-orange-95);--wa-color-warning-90: var(--wa-color-orange-90);--wa-color-warning-80: var(--wa-color-orange-80);--wa-color-warning-70: var(--wa-color-orange-70);--wa-color-warning-60: var(--wa-color-orange-60);--wa-color-warning-50: var(--wa-color-orange-50);--wa-color-warning-40: var(--wa-color-orange-40);--wa-color-warning-30: var(--wa-color-orange-30);--wa-color-warning-20: var(--wa-color-orange-20);--wa-color-warning-10: var(--wa-color-orange-10);--wa-color-warning-05: var(--wa-color-orange-05);--wa-color-warning: var(--wa-color-orange);--wa-color-warning-on: var(--wa-color-orange-on)}.wa-warning-green{--wa-color-warning-95: var(--wa-color-green-95);--wa-color-warning-90: var(--wa-color-green-90);--wa-color-warning-80: var(--wa-color-green-80);--wa-color-warning-70: var(--wa-color-green-70);--wa-color-warning-60: var(--wa-color-green-60);--wa-color-warning-50: var(--wa-color-green-50);--wa-color-warning-40: var(--wa-color-green-40);--wa-color-warning-30: var(--wa-color-green-30);--wa-color-warning-20: var(--wa-color-green-20);--wa-color-warning-10: var(--wa-color-green-10);--wa-color-warning-05: var(--wa-color-green-05);--wa-color-warning: var(--wa-color-green);--wa-color-warning-on: var(--wa-color-green-on)}.wa-warning-cyan{--wa-color-warning-95: var(--wa-color-cyan-95);--wa-color-warning-90: var(--wa-color-cyan-90);--wa-color-warning-80: var(--wa-color-cyan-80);--wa-color-warning-70: var(--wa-color-cyan-70);--wa-color-warning-60: var(--wa-color-cyan-60);--wa-color-warning-50: var(--wa-color-cyan-50);--wa-color-warning-40: var(--wa-color-cyan-40);--wa-color-warning-30: var(--wa-color-cyan-30);--wa-color-warning-20: var(--wa-color-cyan-20);--wa-color-warning-10: var(--wa-color-cyan-10);--wa-color-warning-05: var(--wa-color-cyan-05);--wa-color-warning: var(--wa-color-cyan);--wa-color-warning-on: var(--wa-color-cyan-on)}.wa-warning-blue{--wa-color-warning-95: var(--wa-color-blue-95);--wa-color-warning-90: var(--wa-color-blue-90);--wa-color-warning-80: var(--wa-color-blue-80);--wa-color-warning-70: var(--wa-color-blue-70);--wa-color-warning-60: var(--wa-color-blue-60);--wa-color-warning-50: var(--wa-color-blue-50);--wa-color-warning-40: var(--wa-color-blue-40);--wa-color-warning-30: var(--wa-color-blue-30);--wa-color-warning-20: var(--wa-color-blue-20);--wa-color-warning-10: var(--wa-color-blue-10);--wa-color-warning-05: var(--wa-color-blue-05);--wa-color-warning: var(--wa-color-blue);--wa-color-warning-on: var(--wa-color-blue-on)}.wa-warning-indigo{--wa-color-warning-95: var(--wa-color-indigo-95);--wa-color-warning-90: var(--wa-color-indigo-90);--wa-color-warning-80: var(--wa-color-indigo-80);--wa-color-warning-70: var(--wa-color-indigo-70);--wa-color-warning-60: var(--wa-color-indigo-60);--wa-color-warning-50: var(--wa-color-indigo-50);--wa-color-warning-40: var(--wa-color-indigo-40);--wa-color-warning-30: var(--wa-color-indigo-30);--wa-color-warning-20: var(--wa-color-indigo-20);--wa-color-warning-10: var(--wa-color-indigo-10);--wa-color-warning-05: var(--wa-color-indigo-05);--wa-color-warning: var(--wa-color-indigo);--wa-color-warning-on: var(--wa-color-indigo-on)}.wa-warning-purple{--wa-color-warning-95: var(--wa-color-purple-95);--wa-color-warning-90: var(--wa-color-purple-90);--wa-color-warning-80: var(--wa-color-purple-80);--wa-color-warning-70: var(--wa-color-purple-70);--wa-color-warning-60: var(--wa-color-purple-60);--wa-color-warning-50: var(--wa-color-purple-50);--wa-color-warning-40: var(--wa-color-purple-40);--wa-color-warning-30: var(--wa-color-purple-30);--wa-color-warning-20: var(--wa-color-purple-20);--wa-color-warning-10: var(--wa-color-purple-10);--wa-color-warning-05: var(--wa-color-purple-05);--wa-color-warning: var(--wa-color-purple);--wa-color-warning-on: var(--wa-color-purple-on)}.wa-warning-pink{--wa-color-warning-95: var(--wa-color-pink-95);--wa-color-warning-90: var(--wa-color-pink-90);--wa-color-warning-80: var(--wa-color-pink-80);--wa-color-warning-70: var(--wa-color-pink-70);--wa-color-warning-60: var(--wa-color-pink-60);--wa-color-warning-50: var(--wa-color-pink-50);--wa-color-warning-40: var(--wa-color-pink-40);--wa-color-warning-30: var(--wa-color-pink-30);--wa-color-warning-20: var(--wa-color-pink-20);--wa-color-warning-10: var(--wa-color-pink-10);--wa-color-warning-05: var(--wa-color-pink-05);--wa-color-warning: var(--wa-color-pink);--wa-color-warning-on: var(--wa-color-pink-on)}.wa-warning-gray{--wa-color-warning-95: var(--wa-color-gray-95);--wa-color-warning-90: var(--wa-color-gray-90);--wa-color-warning-80: var(--wa-color-gray-80);--wa-color-warning-70: var(--wa-color-gray-70);--wa-color-warning-60: var(--wa-color-gray-60);--wa-color-warning-50: var(--wa-color-gray-50);--wa-color-warning-40: var(--wa-color-gray-40);--wa-color-warning-30: var(--wa-color-gray-30);--wa-color-warning-20: var(--wa-color-gray-20);--wa-color-warning-10: var(--wa-color-gray-10);--wa-color-warning-05: var(--wa-color-gray-05);--wa-color-warning: var(--wa-color-gray);--wa-color-warning-on: var(--wa-color-gray-on)}}@layer wa-color-variant{:where(:root),.wa-danger-red{--wa-color-danger-95: var(--wa-color-red-95);--wa-color-danger-90: var(--wa-color-red-90);--wa-color-danger-80: var(--wa-color-red-80);--wa-color-danger-70: var(--wa-color-red-70);--wa-color-danger-60: var(--wa-color-red-60);--wa-color-danger-50: var(--wa-color-red-50);--wa-color-danger-40: var(--wa-color-red-40);--wa-color-danger-30: var(--wa-color-red-30);--wa-color-danger-20: var(--wa-color-red-20);--wa-color-danger-10: var(--wa-color-red-10);--wa-color-danger-05: var(--wa-color-red-05);--wa-color-danger: var(--wa-color-red);--wa-color-danger-on: var(--wa-color-red-on)}.wa-danger-orange{--wa-color-danger-95: var(--wa-color-orange-95);--wa-color-danger-90: var(--wa-color-orange-90);--wa-color-danger-80: var(--wa-color-orange-80);--wa-color-danger-70: var(--wa-color-orange-70);--wa-color-danger-60: var(--wa-color-orange-60);--wa-color-danger-50: var(--wa-color-orange-50);--wa-color-danger-40: var(--wa-color-orange-40);--wa-color-danger-30: var(--wa-color-orange-30);--wa-color-danger-20: var(--wa-color-orange-20);--wa-color-danger-10: var(--wa-color-orange-10);--wa-color-danger-05: var(--wa-color-orange-05);--wa-color-danger: var(--wa-color-orange);--wa-color-danger-on: var(--wa-color-orange-on)}.wa-danger-yellow{--wa-color-danger-95: var(--wa-color-yellow-95);--wa-color-danger-90: var(--wa-color-yellow-90);--wa-color-danger-80: var(--wa-color-yellow-80);--wa-color-danger-70: var(--wa-color-yellow-70);--wa-color-danger-60: var(--wa-color-yellow-60);--wa-color-danger-50: var(--wa-color-yellow-50);--wa-color-danger-40: var(--wa-color-yellow-40);--wa-color-danger-30: var(--wa-color-yellow-30);--wa-color-danger-20: var(--wa-color-yellow-20);--wa-color-danger-10: var(--wa-color-yellow-10);--wa-color-danger-05: var(--wa-color-yellow-05);--wa-color-danger: var(--wa-color-yellow);--wa-color-danger-on: var(--wa-color-yellow-on)}.wa-danger-green{--wa-color-danger-95: var(--wa-color-green-95);--wa-color-danger-90: var(--wa-color-green-90);--wa-color-danger-80: var(--wa-color-green-80);--wa-color-danger-70: var(--wa-color-green-70);--wa-color-danger-60: var(--wa-color-green-60);--wa-color-danger-50: var(--wa-color-green-50);--wa-color-danger-40: var(--wa-color-green-40);--wa-color-danger-30: var(--wa-color-green-30);--wa-color-danger-20: var(--wa-color-green-20);--wa-color-danger-10: var(--wa-color-green-10);--wa-color-danger-05: var(--wa-color-green-05);--wa-color-danger: var(--wa-color-green);--wa-color-danger-on: var(--wa-color-green-on)}.wa-danger-cyan{--wa-color-danger-95: var(--wa-color-cyan-95);--wa-color-danger-90: var(--wa-color-cyan-90);--wa-color-danger-80: var(--wa-color-cyan-80);--wa-color-danger-70: var(--wa-color-cyan-70);--wa-color-danger-60: var(--wa-color-cyan-60);--wa-color-danger-50: var(--wa-color-cyan-50);--wa-color-danger-40: var(--wa-color-cyan-40);--wa-color-danger-30: var(--wa-color-cyan-30);--wa-color-danger-20: var(--wa-color-cyan-20);--wa-color-danger-10: var(--wa-color-cyan-10);--wa-color-danger-05: var(--wa-color-cyan-05);--wa-color-danger: var(--wa-color-cyan);--wa-color-danger-on: var(--wa-color-cyan-on)}.wa-danger-blue{--wa-color-danger-95: var(--wa-color-blue-95);--wa-color-danger-90: var(--wa-color-blue-90);--wa-color-danger-80: var(--wa-color-blue-80);--wa-color-danger-70: var(--wa-color-blue-70);--wa-color-danger-60: var(--wa-color-blue-60);--wa-color-danger-50: var(--wa-color-blue-50);--wa-color-danger-40: var(--wa-color-blue-40);--wa-color-danger-30: var(--wa-color-blue-30);--wa-color-danger-20: var(--wa-color-blue-20);--wa-color-danger-10: var(--wa-color-blue-10);--wa-color-danger-05: var(--wa-color-blue-05);--wa-color-danger: var(--wa-color-blue);--wa-color-danger-on: var(--wa-color-blue-on)}.wa-danger-indigo{--wa-color-danger-95: var(--wa-color-indigo-95);--wa-color-danger-90: var(--wa-color-indigo-90);--wa-color-danger-80: var(--wa-color-indigo-80);--wa-color-danger-70: var(--wa-color-indigo-70);--wa-color-danger-60: var(--wa-color-indigo-60);--wa-color-danger-50: var(--wa-color-indigo-50);--wa-color-danger-40: var(--wa-color-indigo-40);--wa-color-danger-30: var(--wa-color-indigo-30);--wa-color-danger-20: var(--wa-color-indigo-20);--wa-color-danger-10: var(--wa-color-indigo-10);--wa-color-danger-05: var(--wa-color-indigo-05);--wa-color-danger: var(--wa-color-indigo);--wa-color-danger-on: var(--wa-color-indigo-on)}.wa-danger-purple{--wa-color-danger-95: var(--wa-color-purple-95);--wa-color-danger-90: var(--wa-color-purple-90);--wa-color-danger-80: var(--wa-color-purple-80);--wa-color-danger-70: var(--wa-color-purple-70);--wa-color-danger-60: var(--wa-color-purple-60);--wa-color-danger-50: var(--wa-color-purple-50);--wa-color-danger-40: var(--wa-color-purple-40);--wa-color-danger-30: var(--wa-color-purple-30);--wa-color-danger-20: var(--wa-color-purple-20);--wa-color-danger-10: var(--wa-color-purple-10);--wa-color-danger-05: var(--wa-color-purple-05);--wa-color-danger: var(--wa-color-purple);--wa-color-danger-on: var(--wa-color-purple-on)}.wa-danger-pink{--wa-color-danger-95: var(--wa-color-pink-95);--wa-color-danger-90: var(--wa-color-pink-90);--wa-color-danger-80: var(--wa-color-pink-80);--wa-color-danger-70: var(--wa-color-pink-70);--wa-color-danger-60: var(--wa-color-pink-60);--wa-color-danger-50: var(--wa-color-pink-50);--wa-color-danger-40: var(--wa-color-pink-40);--wa-color-danger-30: var(--wa-color-pink-30);--wa-color-danger-20: var(--wa-color-pink-20);--wa-color-danger-10: var(--wa-color-pink-10);--wa-color-danger-05: var(--wa-color-pink-05);--wa-color-danger: var(--wa-color-pink);--wa-color-danger-on: var(--wa-color-pink-on)}.wa-danger-gray{--wa-color-danger-95: var(--wa-color-gray-95);--wa-color-danger-90: var(--wa-color-gray-90);--wa-color-danger-80: var(--wa-color-gray-80);--wa-color-danger-70: var(--wa-color-gray-70);--wa-color-danger-60: var(--wa-color-gray-60);--wa-color-danger-50: var(--wa-color-gray-50);--wa-color-danger-40: var(--wa-color-gray-40);--wa-color-danger-30: var(--wa-color-gray-30);--wa-color-danger-20: var(--wa-color-gray-20);--wa-color-danger-10: var(--wa-color-gray-10);--wa-color-danger-05: var(--wa-color-gray-05);--wa-color-danger: var(--wa-color-gray);--wa-color-danger-on: var(--wa-color-gray-on)}}@layer wa-color-palette{:where(:root),.wa-palette-default{--wa-color-red-95: #fff0ef ;--wa-color-red-90: #ffdedc ;--wa-color-red-80: #ffb8b6 ;--wa-color-red-70: #fd8f90 ;--wa-color-red-60: #f3676c ;--wa-color-red-50: #dc3146 ;--wa-color-red-40: #b30532 ;--wa-color-red-30: #8a132c ;--wa-color-red-20: #631323 ;--wa-color-red-10: #3e0913 ;--wa-color-red-05: #2a040b ;--wa-color-red: var(--wa-color-red-50);--wa-color-red-key: 50;--wa-color-orange-95: #fff0e6 ;--wa-color-orange-90: #ffdfca ;--wa-color-orange-80: #ffbb94 ;--wa-color-orange-70: #ff9266 ;--wa-color-orange-60: #f46a45 ;--wa-color-orange-50: #cd491c ;--wa-color-orange-40: #9f3501 ;--wa-color-orange-30: #802700 ;--wa-color-orange-20: #601b00 ;--wa-color-orange-10: #3c0d00 ;--wa-color-orange-05: #280600 ;--wa-color-orange: var(--wa-color-orange-60);--wa-color-orange-key: 60;--wa-color-yellow-95: #fef3cd ;--wa-color-yellow-90: #ffe495 ;--wa-color-yellow-80: #fac22b ;--wa-color-yellow-70: #ef9d00 ;--wa-color-yellow-60: #da7e00 ;--wa-color-yellow-50: #b45f04 ;--wa-color-yellow-40: #8c4602 ;--wa-color-yellow-30: #6f3601 ;--wa-color-yellow-20: #532600 ;--wa-color-yellow-10: #331600 ;--wa-color-yellow-05: #220c00 ;--wa-color-yellow: var(--wa-color-yellow-80);--wa-color-yellow-key: 80;--wa-color-green-95: #e3f9e3 ;--wa-color-green-90: #c2f2c1 ;--wa-color-green-80: #93da98 ;--wa-color-green-70: #5dc36f ;--wa-color-green-60: #00ac49 ;--wa-color-green-50: #00883c ;--wa-color-green-40: #036730 ;--wa-color-green-30: #0a5027 ;--wa-color-green-20: #0a3a1d ;--wa-color-green-10: #052310 ;--wa-color-green-05: #031608 ;--wa-color-green: var(--wa-color-green-60);--wa-color-green-key: 60;--wa-color-cyan-95: #e3f6fb ;--wa-color-cyan-90: #c5ecf7 ;--wa-color-cyan-80: #7fd6ec ;--wa-color-cyan-70: #2fbedc ;--wa-color-cyan-60: #00a3c0 ;--wa-color-cyan-50: #078098 ;--wa-color-cyan-40: #026274 ;--wa-color-cyan-30: #014c5b ;--wa-color-cyan-20: #003844 ;--wa-color-cyan-10: #002129 ;--wa-color-cyan-05: #00151b ;--wa-color-cyan: var(--wa-color-cyan-70);--wa-color-cyan-key: 70;--wa-color-blue-95: #e8f3ff ;--wa-color-blue-90: #d1e8ff ;--wa-color-blue-80: #9fceff ;--wa-color-blue-70: #6eb3ff ;--wa-color-blue-60: #3e96ff ;--wa-color-blue-50: #0071ec ;--wa-color-blue-40: #0053c0 ;--wa-color-blue-30: #003f9c ;--wa-color-blue-20: #002d77 ;--wa-color-blue-10: #001a4e ;--wa-color-blue-05: #000f35 ;--wa-color-blue: var(--wa-color-blue-50);--wa-color-blue-key: 50;--wa-color-indigo-95: #f0f2ff ;--wa-color-indigo-90: #dfe5ff ;--wa-color-indigo-80: #bcc7ff ;--wa-color-indigo-70: #9da9ff ;--wa-color-indigo-60: #808aff ;--wa-color-indigo-50: #6163f2 ;--wa-color-indigo-40: #4945cb ;--wa-color-indigo-30: #3933a7 ;--wa-color-indigo-20: #292381 ;--wa-color-indigo-10: #181255 ;--wa-color-indigo-05: #0d0a3a ;--wa-color-indigo: var(--wa-color-indigo-50);--wa-color-indigo-key: 50;--wa-color-purple-95: #f7f0ff ;--wa-color-purple-90: #eedfff ;--wa-color-purple-80: #ddbdff ;--wa-color-purple-70: #ca99ff ;--wa-color-purple-60: #b678f5 ;--wa-color-purple-50: #9951db ;--wa-color-purple-40: #7936b3 ;--wa-color-purple-30: #612692 ;--wa-color-purple-20: #491870 ;--wa-color-purple-10: #2d0b48 ;--wa-color-purple-05: #1e0532 ;--wa-color-purple: var(--wa-color-purple-50);--wa-color-purple-key: 50;--wa-color-pink-95: #feeff9 ;--wa-color-pink-90: #feddf0 ;--wa-color-pink-80: #fcb5d8 ;--wa-color-pink-70: #f78dbf ;--wa-color-pink-60: #e66ba3 ;--wa-color-pink-50: #c84382 ;--wa-color-pink-40: #9e2a6c ;--wa-color-pink-30: #7d1e58 ;--wa-color-pink-20: #5e1342 ;--wa-color-pink-10: #3c0828 ;--wa-color-pink-05: #28041a ;--wa-color-pink: var(--wa-color-pink-50);--wa-color-pink-key: 50;--wa-color-gray-95: #f1f2f3 ;--wa-color-gray-90: #e4e5e9 ;--wa-color-gray-80: #c7c9d0 ;--wa-color-gray-70: #abaeb9 ;--wa-color-gray-60: #9194a2 ;--wa-color-gray-50: #717584 ;--wa-color-gray-40: #545868 ;--wa-color-gray-30: #424554 ;--wa-color-gray-20: #2f323f ;--wa-color-gray-10: #1b1d26 ;--wa-color-gray-05: #101219 ;--wa-color-gray: var(--wa-color-gray-40);--wa-color-gray-key: 40}}@layer wa-theme{:where(:root),.wa-theme-default,.wa-light,.wa-dark .wa-invert,.wa-light .wa-theme-default,.wa-dark .wa-theme-default.wa-invert,.wa-dark .wa-theme-default .wa-invert{color-scheme:light;color:var(--wa-color-text-normal);--wa-color-surface-raised: white;--wa-color-surface-default: white;--wa-color-surface-lowered: var(--wa-color-neutral-95);--wa-color-surface-border: var(--wa-color-neutral-90);--wa-color-text-normal: var(--wa-color-neutral-10);--wa-color-text-quiet: var(--wa-color-neutral-40);--wa-color-text-link: var(--wa-color-brand-40);--wa-color-overlay-modal: color-mix(in oklab, var(--wa-color-neutral-05) 50%, transparent);--wa-color-overlay-inline: color-mix(in oklab, var(--wa-color-neutral-80) 25%, transparent);--wa-color-shadow: color-mix( in oklab, var(--wa-color-neutral-05) calc(var(--wa-shadow-blur-scale) * 4% + 8%), transparent );--wa-color-focus: var(--wa-color-brand-60);--wa-color-mix-hover: black 10%;--wa-color-mix-active: black 20%;--wa-color-brand-fill-quiet: var(--wa-color-brand-95);--wa-color-brand-fill-normal: var(--wa-color-brand-90);--wa-color-brand-fill-loud: var(--wa-color-brand-50);--wa-color-brand-border-quiet: var(--wa-color-brand-90);--wa-color-brand-border-normal: var(--wa-color-brand-80);--wa-color-brand-border-loud: var(--wa-color-brand-60);--wa-color-brand-on-quiet: var(--wa-color-brand-40);--wa-color-brand-on-normal: var(--wa-color-brand-30);--wa-color-brand-on-loud: white;--wa-color-success-fill-quiet: var(--wa-color-success-95);--wa-color-success-fill-normal: var(--wa-color-success-90);--wa-color-success-fill-loud: var(--wa-color-success-50);--wa-color-success-border-quiet: var(--wa-color-success-90);--wa-color-success-border-normal: var(--wa-color-success-80);--wa-color-success-border-loud: var(--wa-color-success-60);--wa-color-success-on-quiet: var(--wa-color-success-40);--wa-color-success-on-normal: var(--wa-color-success-30);--wa-color-success-on-loud: white;--wa-color-warning-fill-quiet: var(--wa-color-warning-95);--wa-color-warning-fill-normal: var(--wa-color-warning-90);--wa-color-warning-fill-loud: var(--wa-color-warning-50);--wa-color-warning-border-quiet: var(--wa-color-warning-90);--wa-color-warning-border-normal: var(--wa-color-warning-80);--wa-color-warning-border-loud: var(--wa-color-warning-60);--wa-color-warning-on-quiet: var(--wa-color-warning-40);--wa-color-warning-on-normal: var(--wa-color-warning-30);--wa-color-warning-on-loud: white;--wa-color-danger-fill-quiet: var(--wa-color-danger-95);--wa-color-danger-fill-normal: var(--wa-color-danger-90);--wa-color-danger-fill-loud: var(--wa-color-danger-50);--wa-color-danger-border-quiet: var(--wa-color-danger-90);--wa-color-danger-border-normal: var(--wa-color-danger-80);--wa-color-danger-border-loud: var(--wa-color-danger-60);--wa-color-danger-on-quiet: var(--wa-color-danger-40);--wa-color-danger-on-normal: var(--wa-color-danger-30);--wa-color-danger-on-loud: white;--wa-color-neutral-fill-quiet: var(--wa-color-neutral-95);--wa-color-neutral-fill-normal: var(--wa-color-neutral-90);--wa-color-neutral-fill-loud: var(--wa-color-neutral-20);--wa-color-neutral-border-quiet: var(--wa-color-neutral-90);--wa-color-neutral-border-normal: var(--wa-color-neutral-80);--wa-color-neutral-border-loud: var(--wa-color-neutral-60);--wa-color-neutral-on-quiet: var(--wa-color-neutral-40);--wa-color-neutral-on-normal: var(--wa-color-neutral-30);--wa-color-neutral-on-loud: white}.wa-dark,.wa-invert,.wa-dark .wa-theme-default,.wa-light .wa-theme-default.wa-invert,.wa-light .wa-theme-default .wa-invert{color-scheme:dark;color:var(--wa-color-text-normal);--wa-color-surface-raised: var(--wa-color-neutral-10);--wa-color-surface-default: var(--wa-color-neutral-05);--wa-color-surface-lowered: color-mix(in oklab, var(--wa-color-surface-default), black 20%);--wa-color-surface-border: var(--wa-color-neutral-20);--wa-color-text-normal: var(--wa-color-neutral-95);--wa-color-text-quiet: var(--wa-color-neutral-60);--wa-color-text-link: var(--wa-color-brand-70);--wa-color-overlay-modal: color-mix(in oklab, black 60%, transparent);--wa-color-overlay-inline: color-mix(in oklab, var(--wa-color-neutral-50) 10%, transparent);--wa-color-shadow: color-mix( in oklab, var(--wa-color-surface-lowered) calc(var(--wa-shadow-blur-scale) * 32% + 40%), transparent );--wa-color-focus: var(--wa-color-brand-60);--wa-color-mix-hover: black 8%;--wa-color-mix-active: black 16%;--wa-color-brand-fill-quiet: var(--wa-color-brand-10);--wa-color-brand-fill-normal: var(--wa-color-brand-20);--wa-color-brand-fill-loud: var(--wa-color-brand-50);--wa-color-brand-border-quiet: var(--wa-color-brand-20);--wa-color-brand-border-normal: var(--wa-color-brand-30);--wa-color-brand-border-loud: var(--wa-color-brand-40);--wa-color-brand-on-quiet: var(--wa-color-brand-60);--wa-color-brand-on-normal: var(--wa-color-brand-70);--wa-color-brand-on-loud: white;--wa-color-success-fill-quiet: var(--wa-color-success-10);--wa-color-success-fill-normal: var(--wa-color-success-20);--wa-color-success-fill-loud: var(--wa-color-success-50);--wa-color-success-border-quiet: var(--wa-color-success-20);--wa-color-success-border-normal: var(--wa-color-success-30);--wa-color-success-border-loud: var(--wa-color-success-40);--wa-color-success-on-quiet: var(--wa-color-success-60);--wa-color-success-on-normal: var(--wa-color-success-70);--wa-color-success-on-loud: white;--wa-color-warning-fill-quiet: var(--wa-color-warning-10);--wa-color-warning-fill-normal: var(--wa-color-warning-20);--wa-color-warning-fill-loud: var(--wa-color-warning-50);--wa-color-warning-border-quiet: var(--wa-color-warning-20);--wa-color-warning-border-normal: var(--wa-color-warning-30);--wa-color-warning-border-loud: var(--wa-color-warning-40);--wa-color-warning-on-quiet: var(--wa-color-warning-60);--wa-color-warning-on-normal: var(--wa-color-warning-70);--wa-color-warning-on-loud: white;--wa-color-danger-fill-quiet: var(--wa-color-danger-10);--wa-color-danger-fill-normal: var(--wa-color-danger-20);--wa-color-danger-fill-loud: var(--wa-color-danger-50);--wa-color-danger-border-quiet: var(--wa-color-danger-20);--wa-color-danger-border-normal: var(--wa-color-danger-30);--wa-color-danger-border-loud: var(--wa-color-danger-40);--wa-color-danger-on-quiet: var(--wa-color-danger-60);--wa-color-danger-on-normal: var(--wa-color-danger-70);--wa-color-danger-on-loud: white;--wa-color-neutral-fill-quiet: var(--wa-color-neutral-10);--wa-color-neutral-fill-normal: var(--wa-color-neutral-20);--wa-color-neutral-fill-loud: var(--wa-color-neutral-90);--wa-color-neutral-border-quiet: var(--wa-color-neutral-20);--wa-color-neutral-border-normal: var(--wa-color-neutral-30);--wa-color-neutral-border-loud: var(--wa-color-neutral-40);--wa-color-neutral-on-quiet: var(--wa-color-neutral-60);--wa-color-neutral-on-normal: var(--wa-color-neutral-70);--wa-color-neutral-on-loud: var(--wa-color-neutral-05)}:where(:root),.wa-theme-default,.wa-light,.wa-dark,.wa-invert{font-family:var(--wa-font-family-body);--wa-font-family-body: ui-sans-serif, system-ui, sans-serif;--wa-font-family-heading: var(--wa-font-family-body);--wa-font-family-code: ui-monospace, monospace;--wa-font-family-longform: ui-serif, serif;--wa-font-size-scale: 1;--wa-font-size-2xs: round(calc(var(--wa-font-size-xs) / 1.125), 1px);--wa-font-size-xs: round(calc(var(--wa-font-size-s) / 1.125), 1px);--wa-font-size-s: round(calc(var(--wa-font-size-m) / 1.125), 1px);--wa-font-size-m: calc(1rem * var(--wa-font-size-scale));--wa-font-size-l: round(calc(var(--wa-font-size-m) * 1.125 * 1.125), 1px);--wa-font-size-xl: round(calc(var(--wa-font-size-l) * 1.125 * 1.125), 1px);--wa-font-size-2xl: round(calc(var(--wa-font-size-xl) * 1.125 * 1.125), 1px);--wa-font-size-3xl: round(calc(var(--wa-font-size-2xl) * 1.125 * 1.125), 1px);--wa-font-size-4xl: round(calc(var(--wa-font-size-3xl) * 1.125 * 1.125), 1px);--wa-font-size-smaller: round(calc(1em / 1.125), 1px);--wa-font-size-larger: round(calc(1em * 1.125 * 1.125), 1px);--wa-font-weight-light: 300;--wa-font-weight-normal: 400;--wa-font-weight-semibold: 500;--wa-font-weight-bold: 600;--wa-font-weight-body: var(--wa-font-weight-normal);--wa-font-weight-heading: var(--wa-font-weight-bold);--wa-font-weight-code: var(--wa-font-weight-normal);--wa-font-weight-longform: var(--wa-font-weight-normal);--wa-font-weight-action: var(--wa-font-weight-semibold);--wa-line-height-condensed: 1.2;--wa-line-height-normal: 1.6;--wa-line-height-expanded: 2;--wa-link-decoration-default: underline color-mix(in oklab, currentColor 70%, transparent) dotted;--wa-link-decoration-hover: underline;--wa-space-scale: 1;--wa-space-3xs: calc(var(--wa-space-scale) * .125rem);--wa-space-2xs: calc(var(--wa-space-scale) * .25rem);--wa-space-xs: calc(var(--wa-space-scale) * .5rem);--wa-space-s: calc(var(--wa-space-scale) * .75rem);--wa-space-m: calc(var(--wa-space-scale) * 1rem);--wa-space-l: calc(var(--wa-space-scale) * 1.5rem);--wa-space-xl: calc(var(--wa-space-scale) * 2rem);--wa-space-2xl: calc(var(--wa-space-scale) * 2.5rem);--wa-space-3xl: calc(var(--wa-space-scale) * 3rem);--wa-space-4xl: calc(var(--wa-space-scale) * 4rem);--wa-content-spacing: var(--wa-space-l);--wa-border-style: solid;--wa-border-width-scale: 1;--wa-border-width-s: calc(var(--wa-border-width-scale) * .0625rem);--wa-border-width-m: calc(var(--wa-border-width-scale) * .125rem);--wa-border-width-l: calc(var(--wa-border-width-scale) * .1875rem);--wa-border-radius-scale: 1;--wa-border-radius-s: calc(var(--wa-border-radius-scale) * .1875rem);--wa-border-radius-m: calc(var(--wa-border-radius-scale) * .375rem);--wa-border-radius-l: calc(var(--wa-border-radius-scale) * .75rem);--wa-border-radius-pill: 9999px;--wa-border-radius-circle: 50%;--wa-border-radius-square: 0px;--wa-focus-ring-style: solid;--wa-focus-ring-width: .1875rem;--wa-focus-ring: var(--wa-focus-ring-style) var(--wa-focus-ring-width) var(--wa-color-focus);--wa-focus-ring-offset: .0625rem;--wa-shadow-offset-x-scale: 0;--wa-shadow-offset-x-s: calc(var(--wa-shadow-offset-x-scale) * .125rem);--wa-shadow-offset-x-m: calc(var(--wa-shadow-offset-x-scale) * .25rem);--wa-shadow-offset-x-l: calc(var(--wa-shadow-offset-x-scale) * .5rem);--wa-shadow-offset-y-scale: 1;--wa-shadow-offset-y-s: calc(var(--wa-shadow-offset-y-scale) * .125rem);--wa-shadow-offset-y-m: calc(var(--wa-shadow-offset-y-scale) * .25rem);--wa-shadow-offset-y-l: calc(var(--wa-shadow-offset-y-scale) * .5rem);--wa-shadow-blur-scale: 1;--wa-shadow-blur-s: calc(var(--wa-shadow-blur-scale) * .125rem);--wa-shadow-blur-m: calc(var(--wa-shadow-blur-scale) * .25rem);--wa-shadow-blur-l: calc(var(--wa-shadow-blur-scale) * .5rem);--wa-shadow-spread-scale: -.5;--wa-shadow-spread-s: calc(var(--wa-shadow-spread-scale) * .125rem);--wa-shadow-spread-m: calc(var(--wa-shadow-spread-scale) * .25rem);--wa-shadow-spread-l: calc(var(--wa-shadow-spread-scale) * .5rem);--wa-shadow-s: var(--wa-shadow-offset-x-s) var(--wa-shadow-offset-y-s) var(--wa-shadow-blur-s) var(--wa-shadow-spread-s) var(--wa-color-shadow);--wa-shadow-m: var(--wa-shadow-offset-x-m) var(--wa-shadow-offset-y-m) var(--wa-shadow-blur-m) var(--wa-shadow-spread-m) var(--wa-color-shadow);--wa-shadow-l: var(--wa-shadow-offset-x-l) var(--wa-shadow-offset-y-l) var(--wa-shadow-blur-l) var(--wa-shadow-spread-l) var(--wa-color-shadow);--wa-transition-easing: ease;--wa-transition-slow: .3s;--wa-transition-normal: .15s;--wa-transition-fast: 75ms;--wa-form-control-background-color: var(--wa-color-surface-default);--wa-form-control-border-color: var(--wa-color-neutral-border-loud);--wa-form-control-border-style: var(--wa-border-style);--wa-form-control-border-width: var(--wa-border-width-s);--wa-form-control-border-radius: var(--wa-border-radius-m);--wa-form-control-activated-color: var(--wa-color-brand-fill-loud);--wa-form-control-label-color: var(--wa-color-text-normal);--wa-form-control-label-font-weight: var(--wa-font-weight-semibold);--wa-form-control-label-line-height: var(--wa-line-height-condensed);--wa-form-control-value-color: var(--wa-color-text-normal);--wa-form-control-value-font-weight: var(--wa-font-weight-body);--wa-form-control-value-line-height: var(--wa-line-height-condensed);--wa-form-control-hint-color: var(--wa-color-text-quiet);--wa-form-control-hint-font-weight: var(--wa-font-weight-body);--wa-form-control-hint-line-height: var(--wa-line-height-normal);--wa-form-control-placeholder-color: var(--wa-color-gray-50);--wa-form-control-required-content: "*";--wa-form-control-required-content-color: inherit;--wa-form-control-required-content-offset: .1em;--wa-form-control-padding-block: .75em;--wa-form-control-padding-inline: 1em;--wa-form-control-height: round( calc(2 * var(--wa-form-control-padding-block) + 1em * var(--wa-form-control-value-line-height)), 1px );--wa-form-control-toggle-size: round(1.25em, 1px);--wa-panel-border-style: var(--wa-border-style);--wa-panel-border-width: var(--wa-border-width-s);--wa-panel-border-radius: var(--wa-border-radius-l);--wa-tooltip-arrow-size: .375rem;--wa-tooltip-background-color: var(--wa-color-text-normal);--wa-tooltip-border-color: var(--wa-tooltip-background-color);--wa-tooltip-border-style: var(--wa-border-style);--wa-tooltip-border-width: var(--wa-border-width-s);--wa-tooltip-border-radius: var(--wa-border-radius-s);--wa-tooltip-content-color: var(--wa-color-surface-default);--wa-tooltip-font-size: var(--wa-font-size-s);--wa-tooltip-line-height: var(--wa-line-height-normal)}}')),document.head.appendChild(o)}}catch(a){console.error("vite-plugin-css-injected-by-js",a)}})();
var bi = Object.defineProperty;
var vi = (e, t, i) => t in e ? bi(e, t, { enumerable: !0, configurable: !0, writable: !0, value: i }) : e[t] = i;
var Gt = (e, t, i) => vi(e, typeof t != "symbol" ? t + "" : t, i);
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Lt = globalThis, ce = Lt.ShadowRoot && (Lt.ShadyCSS === void 0 || Lt.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype, ue = Symbol(), $e = /* @__PURE__ */ new WeakMap();
let je = class {
  constructor(t, i, s) {
    if (this._$cssResult$ = !0, s !== ue) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = t, this.t = i;
  }
  get styleSheet() {
    let t = this.o;
    const i = this.t;
    if (ce && t === void 0) {
      const s = i !== void 0 && i.length === 1;
      s && (t = $e.get(i)), t === void 0 && ((this.o = t = new CSSStyleSheet()).replaceSync(this.cssText), s && $e.set(i, t));
    }
    return t;
  }
  toString() {
    return this.cssText;
  }
};
const Ke = (e) => new je(typeof e == "string" ? e : e + "", void 0, ue), yi = (e, ...t) => {
  const i = e.length === 1 ? e[0] : t.reduce((s, n, o) => s + ((r) => {
    if (r._$cssResult$ === !0) return r.cssText;
    if (typeof r == "number") return r;
    throw Error("Value passed to 'css' function must be a 'css' function result: " + r + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
  })(n) + e[o + 1], e[0]);
  return new je(i, e, ue);
}, wi = (e, t) => {
  if (ce) e.adoptedStyleSheets = t.map((i) => i instanceof CSSStyleSheet ? i : i.styleSheet);
  else for (const i of t) {
    const s = document.createElement("style"), n = Lt.litNonce;
    n !== void 0 && s.setAttribute("nonce", n), s.textContent = i.cssText, e.appendChild(s);
  }
}, Ee = ce ? (e) => e : (e) => e instanceof CSSStyleSheet ? ((t) => {
  let i = "";
  for (const s of t.cssRules) i += s.cssText;
  return Ke(i);
})(e) : e;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const { is: xi, defineProperty: $i, getOwnPropertyDescriptor: Ei, getOwnPropertyNames: Ai, getOwnPropertySymbols: Si, getPrototypeOf: Ci } = Object, tt = globalThis, Ae = tt.trustedTypes, _i = Ae ? Ae.emptyScript : "", Jt = tt.reactiveElementPolyfillSupport, Ct = (e, t) => e, Bt = { toAttribute(e, t) {
  switch (t) {
    case Boolean:
      e = e ? _i : null;
      break;
    case Object:
    case Array:
      e = e == null ? e : JSON.stringify(e);
  }
  return e;
}, fromAttribute(e, t) {
  let i = e;
  switch (t) {
    case Boolean:
      i = e !== null;
      break;
    case Number:
      i = e === null ? null : Number(e);
      break;
    case Object:
    case Array:
      try {
        i = JSON.parse(e);
      } catch {
        i = null;
      }
  }
  return i;
} }, de = (e, t) => !xi(e, t), Se = { attribute: !0, type: String, converter: Bt, reflect: !1, useDefault: !1, hasChanged: de };
Symbol.metadata ?? (Symbol.metadata = Symbol("metadata")), tt.litPropertyMetadata ?? (tt.litPropertyMetadata = /* @__PURE__ */ new WeakMap());
let pt = class extends HTMLElement {
  static addInitializer(t) {
    this._$Ei(), (this.l ?? (this.l = [])).push(t);
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()];
  }
  static createProperty(t, i = Se) {
    if (i.state && (i.attribute = !1), this._$Ei(), this.prototype.hasOwnProperty(t) && ((i = Object.create(i)).wrapped = !0), this.elementProperties.set(t, i), !i.noAccessor) {
      const s = Symbol(), n = this.getPropertyDescriptor(t, s, i);
      n !== void 0 && $i(this.prototype, t, n);
    }
  }
  static getPropertyDescriptor(t, i, s) {
    const { get: n, set: o } = Ei(this.prototype, t) ?? { get() {
      return this[i];
    }, set(r) {
      this[i] = r;
    } };
    return { get: n, set(r) {
      const a = n == null ? void 0 : n.call(this);
      o == null || o.call(this, r), this.requestUpdate(t, a, s);
    }, configurable: !0, enumerable: !0 };
  }
  static getPropertyOptions(t) {
    return this.elementProperties.get(t) ?? Se;
  }
  static _$Ei() {
    if (this.hasOwnProperty(Ct("elementProperties"))) return;
    const t = Ci(this);
    t.finalize(), t.l !== void 0 && (this.l = [...t.l]), this.elementProperties = new Map(t.elementProperties);
  }
  static finalize() {
    if (this.hasOwnProperty(Ct("finalized"))) return;
    if (this.finalized = !0, this._$Ei(), this.hasOwnProperty(Ct("properties"))) {
      const i = this.properties, s = [...Ai(i), ...Si(i)];
      for (const n of s) this.createProperty(n, i[n]);
    }
    const t = this[Symbol.metadata];
    if (t !== null) {
      const i = litPropertyMetadata.get(t);
      if (i !== void 0) for (const [s, n] of i) this.elementProperties.set(s, n);
    }
    this._$Eh = /* @__PURE__ */ new Map();
    for (const [i, s] of this.elementProperties) {
      const n = this._$Eu(i, s);
      n !== void 0 && this._$Eh.set(n, i);
    }
    this.elementStyles = this.finalizeStyles(this.styles);
  }
  static finalizeStyles(t) {
    const i = [];
    if (Array.isArray(t)) {
      const s = new Set(t.flat(1 / 0).reverse());
      for (const n of s) i.unshift(Ee(n));
    } else t !== void 0 && i.push(Ee(t));
    return i;
  }
  static _$Eu(t, i) {
    const s = i.attribute;
    return s === !1 ? void 0 : typeof s == "string" ? s : typeof t == "string" ? t.toLowerCase() : void 0;
  }
  constructor() {
    super(), this._$Ep = void 0, this.isUpdatePending = !1, this.hasUpdated = !1, this._$Em = null, this._$Ev();
  }
  _$Ev() {
    var t;
    this._$ES = new Promise((i) => this.enableUpdating = i), this._$AL = /* @__PURE__ */ new Map(), this._$E_(), this.requestUpdate(), (t = this.constructor.l) == null || t.forEach((i) => i(this));
  }
  addController(t) {
    var i;
    (this._$EO ?? (this._$EO = /* @__PURE__ */ new Set())).add(t), this.renderRoot !== void 0 && this.isConnected && ((i = t.hostConnected) == null || i.call(t));
  }
  removeController(t) {
    var i;
    (i = this._$EO) == null || i.delete(t);
  }
  _$E_() {
    const t = /* @__PURE__ */ new Map(), i = this.constructor.elementProperties;
    for (const s of i.keys()) this.hasOwnProperty(s) && (t.set(s, this[s]), delete this[s]);
    t.size > 0 && (this._$Ep = t);
  }
  createRenderRoot() {
    const t = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
    return wi(t, this.constructor.elementStyles), t;
  }
  connectedCallback() {
    var t;
    this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this.enableUpdating(!0), (t = this._$EO) == null || t.forEach((i) => {
      var s;
      return (s = i.hostConnected) == null ? void 0 : s.call(i);
    });
  }
  enableUpdating(t) {
  }
  disconnectedCallback() {
    var t;
    (t = this._$EO) == null || t.forEach((i) => {
      var s;
      return (s = i.hostDisconnected) == null ? void 0 : s.call(i);
    });
  }
  attributeChangedCallback(t, i, s) {
    this._$AK(t, s);
  }
  _$ET(t, i) {
    var o;
    const s = this.constructor.elementProperties.get(t), n = this.constructor._$Eu(t, s);
    if (n !== void 0 && s.reflect === !0) {
      const r = (((o = s.converter) == null ? void 0 : o.toAttribute) !== void 0 ? s.converter : Bt).toAttribute(i, s.type);
      this._$Em = t, r == null ? this.removeAttribute(n) : this.setAttribute(n, r), this._$Em = null;
    }
  }
  _$AK(t, i) {
    var o, r;
    const s = this.constructor, n = s._$Eh.get(t);
    if (n !== void 0 && this._$Em !== n) {
      const a = s.getPropertyOptions(n), l = typeof a.converter == "function" ? { fromAttribute: a.converter } : ((o = a.converter) == null ? void 0 : o.fromAttribute) !== void 0 ? a.converter : Bt;
      this._$Em = n;
      const h = l.fromAttribute(i, a.type);
      this[n] = h ?? ((r = this._$Ej) == null ? void 0 : r.get(n)) ?? h, this._$Em = null;
    }
  }
  requestUpdate(t, i, s) {
    var n;
    if (t !== void 0) {
      const o = this.constructor, r = this[t];
      if (s ?? (s = o.getPropertyOptions(t)), !((s.hasChanged ?? de)(r, i) || s.useDefault && s.reflect && r === ((n = this._$Ej) == null ? void 0 : n.get(t)) && !this.hasAttribute(o._$Eu(t, s)))) return;
      this.C(t, i, s);
    }
    this.isUpdatePending === !1 && (this._$ES = this._$EP());
  }
  C(t, i, { useDefault: s, reflect: n, wrapped: o }, r) {
    s && !(this._$Ej ?? (this._$Ej = /* @__PURE__ */ new Map())).has(t) && (this._$Ej.set(t, r ?? i ?? this[t]), o !== !0 || r !== void 0) || (this._$AL.has(t) || (this.hasUpdated || s || (i = void 0), this._$AL.set(t, i)), n === !0 && this._$Em !== t && (this._$Eq ?? (this._$Eq = /* @__PURE__ */ new Set())).add(t));
  }
  async _$EP() {
    this.isUpdatePending = !0;
    try {
      await this._$ES;
    } catch (i) {
      Promise.reject(i);
    }
    const t = this.scheduleUpdate();
    return t != null && await t, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    var s;
    if (!this.isUpdatePending) return;
    if (!this.hasUpdated) {
      if (this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this._$Ep) {
        for (const [o, r] of this._$Ep) this[o] = r;
        this._$Ep = void 0;
      }
      const n = this.constructor.elementProperties;
      if (n.size > 0) for (const [o, r] of n) {
        const { wrapped: a } = r, l = this[o];
        a !== !0 || this._$AL.has(o) || l === void 0 || this.C(o, void 0, r, l);
      }
    }
    let t = !1;
    const i = this._$AL;
    try {
      t = this.shouldUpdate(i), t ? (this.willUpdate(i), (s = this._$EO) == null || s.forEach((n) => {
        var o;
        return (o = n.hostUpdate) == null ? void 0 : o.call(n);
      }), this.update(i)) : this._$EM();
    } catch (n) {
      throw t = !1, this._$EM(), n;
    }
    t && this._$AE(i);
  }
  willUpdate(t) {
  }
  _$AE(t) {
    var i;
    (i = this._$EO) == null || i.forEach((s) => {
      var n;
      return (n = s.hostUpdated) == null ? void 0 : n.call(s);
    }), this.hasUpdated || (this.hasUpdated = !0, this.firstUpdated(t)), this.updated(t);
  }
  _$EM() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = !1;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$ES;
  }
  shouldUpdate(t) {
    return !0;
  }
  update(t) {
    this._$Eq && (this._$Eq = this._$Eq.forEach((i) => this._$ET(i, this[i]))), this._$EM();
  }
  updated(t) {
  }
  firstUpdated(t) {
  }
};
pt.elementStyles = [], pt.shadowRootOptions = { mode: "open" }, pt[Ct("elementProperties")] = /* @__PURE__ */ new Map(), pt[Ct("finalized")] = /* @__PURE__ */ new Map(), Jt == null || Jt({ ReactiveElement: pt }), (tt.reactiveElementVersions ?? (tt.reactiveElementVersions = [])).push("2.1.1");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const _t = globalThis, Nt = _t.trustedTypes, Ce = Nt ? Nt.createPolicy("lit-html", { createHTML: (e) => e }) : void 0, Xe = "$lit$", Q = `lit$${Math.random().toFixed(9).slice(2)}$`, Ye = "?" + Q, Ti = `<${Ye}>`, ct = document, Tt = () => ct.createComment(""), Vt = (e) => e === null || typeof e != "object" && typeof e != "function", pe = Array.isArray, Vi = (e) => pe(e) || typeof (e == null ? void 0 : e[Symbol.iterator]) == "function", Qt = `[ 	
\f\r]`, St = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g, _e = /-->/g, Te = />/g, rt = RegExp(`>|${Qt}(?:([^\\s"'>=/]+)(${Qt}*=${Qt}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g"), Ve = /'/g, Re = /"/g, Ze = /^(?:script|style|textarea|title)$/i, Ri = (e) => (t, ...i) => ({ _$litType$: e, strings: t, values: i }), D = Ri(1), ut = Symbol.for("lit-noChange"), _ = Symbol.for("lit-nothing"), ke = /* @__PURE__ */ new WeakMap(), lt = ct.createTreeWalker(ct, 129);
function Ge(e, t) {
  if (!pe(e) || !e.hasOwnProperty("raw")) throw Error("invalid template strings array");
  return Ce !== void 0 ? Ce.createHTML(t) : t;
}
const ki = (e, t) => {
  const i = e.length - 1, s = [];
  let n, o = t === 2 ? "<svg>" : t === 3 ? "<math>" : "", r = St;
  for (let a = 0; a < i; a++) {
    const l = e[a];
    let h, c, u = -1, f = 0;
    for (; f < l.length && (r.lastIndex = f, c = r.exec(l), c !== null); ) f = r.lastIndex, r === St ? c[1] === "!--" ? r = _e : c[1] !== void 0 ? r = Te : c[2] !== void 0 ? (Ze.test(c[2]) && (n = RegExp("</" + c[2], "g")), r = rt) : c[3] !== void 0 && (r = rt) : r === rt ? c[0] === ">" ? (r = n ?? St, u = -1) : c[1] === void 0 ? u = -2 : (u = r.lastIndex - c[2].length, h = c[1], r = c[3] === void 0 ? rt : c[3] === '"' ? Re : Ve) : r === Re || r === Ve ? r = rt : r === _e || r === Te ? r = St : (r = rt, n = void 0);
    const d = r === rt && e[a + 1].startsWith("/>") ? " " : "";
    o += r === St ? l + Ti : u >= 0 ? (s.push(h), l.slice(0, u) + Xe + l.slice(u) + Q + d) : l + Q + (u === -2 ? a : d);
  }
  return [Ge(e, o + (e[i] || "<?>") + (t === 2 ? "</svg>" : t === 3 ? "</math>" : "")), s];
};
class Rt {
  constructor({ strings: t, _$litType$: i }, s) {
    let n;
    this.parts = [];
    let o = 0, r = 0;
    const a = t.length - 1, l = this.parts, [h, c] = ki(t, i);
    if (this.el = Rt.createElement(h, s), lt.currentNode = this.el.content, i === 2 || i === 3) {
      const u = this.el.content.firstChild;
      u.replaceWith(...u.childNodes);
    }
    for (; (n = lt.nextNode()) !== null && l.length < a; ) {
      if (n.nodeType === 1) {
        if (n.hasAttributes()) for (const u of n.getAttributeNames()) if (u.endsWith(Xe)) {
          const f = c[r++], d = n.getAttribute(u).split(Q), g = /([.?@])?(.*)/.exec(f);
          l.push({ type: 1, index: o, name: g[2], strings: d, ctor: g[1] === "." ? Oi : g[1] === "?" ? Di : g[1] === "@" ? Mi : Wt }), n.removeAttribute(u);
        } else u.startsWith(Q) && (l.push({ type: 6, index: o }), n.removeAttribute(u));
        if (Ze.test(n.tagName)) {
          const u = n.textContent.split(Q), f = u.length - 1;
          if (f > 0) {
            n.textContent = Nt ? Nt.emptyScript : "";
            for (let d = 0; d < f; d++) n.append(u[d], Tt()), lt.nextNode(), l.push({ type: 2, index: ++o });
            n.append(u[f], Tt());
          }
        }
      } else if (n.nodeType === 8) if (n.data === Ye) l.push({ type: 2, index: o });
      else {
        let u = -1;
        for (; (u = n.data.indexOf(Q, u + 1)) !== -1; ) l.push({ type: 7, index: o }), u += Q.length - 1;
      }
      o++;
    }
  }
  static createElement(t, i) {
    const s = ct.createElement("template");
    return s.innerHTML = t, s;
  }
}
function vt(e, t, i = e, s) {
  var r, a;
  if (t === ut) return t;
  let n = s !== void 0 ? (r = i._$Co) == null ? void 0 : r[s] : i._$Cl;
  const o = Vt(t) ? void 0 : t._$litDirective$;
  return (n == null ? void 0 : n.constructor) !== o && ((a = n == null ? void 0 : n._$AO) == null || a.call(n, !1), o === void 0 ? n = void 0 : (n = new o(e), n._$AT(e, i, s)), s !== void 0 ? (i._$Co ?? (i._$Co = []))[s] = n : i._$Cl = n), n !== void 0 && (t = vt(e, n._$AS(e, t.values), n, s)), t;
}
class Pi {
  constructor(t, i) {
    this._$AV = [], this._$AN = void 0, this._$AD = t, this._$AM = i;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(t) {
    const { el: { content: i }, parts: s } = this._$AD, n = ((t == null ? void 0 : t.creationScope) ?? ct).importNode(i, !0);
    lt.currentNode = n;
    let o = lt.nextNode(), r = 0, a = 0, l = s[0];
    for (; l !== void 0; ) {
      if (r === l.index) {
        let h;
        l.type === 2 ? h = new kt(o, o.nextSibling, this, t) : l.type === 1 ? h = new l.ctor(o, l.name, l.strings, this, t) : l.type === 6 && (h = new Li(o, this, t)), this._$AV.push(h), l = s[++a];
      }
      r !== (l == null ? void 0 : l.index) && (o = lt.nextNode(), r++);
    }
    return lt.currentNode = ct, n;
  }
  p(t) {
    let i = 0;
    for (const s of this._$AV) s !== void 0 && (s.strings !== void 0 ? (s._$AI(t, s, i), i += s.strings.length - 2) : s._$AI(t[i])), i++;
  }
}
class kt {
  get _$AU() {
    var t;
    return ((t = this._$AM) == null ? void 0 : t._$AU) ?? this._$Cv;
  }
  constructor(t, i, s, n) {
    this.type = 2, this._$AH = _, this._$AN = void 0, this._$AA = t, this._$AB = i, this._$AM = s, this.options = n, this._$Cv = (n == null ? void 0 : n.isConnected) ?? !0;
  }
  get parentNode() {
    let t = this._$AA.parentNode;
    const i = this._$AM;
    return i !== void 0 && (t == null ? void 0 : t.nodeType) === 11 && (t = i.parentNode), t;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(t, i = this) {
    t = vt(this, t, i), Vt(t) ? t === _ || t == null || t === "" ? (this._$AH !== _ && this._$AR(), this._$AH = _) : t !== this._$AH && t !== ut && this._(t) : t._$litType$ !== void 0 ? this.$(t) : t.nodeType !== void 0 ? this.T(t) : Vi(t) ? this.k(t) : this._(t);
  }
  O(t) {
    return this._$AA.parentNode.insertBefore(t, this._$AB);
  }
  T(t) {
    this._$AH !== t && (this._$AR(), this._$AH = this.O(t));
  }
  _(t) {
    this._$AH !== _ && Vt(this._$AH) ? this._$AA.nextSibling.data = t : this.T(ct.createTextNode(t)), this._$AH = t;
  }
  $(t) {
    var o;
    const { values: i, _$litType$: s } = t, n = typeof s == "number" ? this._$AC(t) : (s.el === void 0 && (s.el = Rt.createElement(Ge(s.h, s.h[0]), this.options)), s);
    if (((o = this._$AH) == null ? void 0 : o._$AD) === n) this._$AH.p(i);
    else {
      const r = new Pi(n, this), a = r.u(this.options);
      r.p(i), this.T(a), this._$AH = r;
    }
  }
  _$AC(t) {
    let i = ke.get(t.strings);
    return i === void 0 && ke.set(t.strings, i = new Rt(t)), i;
  }
  k(t) {
    pe(this._$AH) || (this._$AH = [], this._$AR());
    const i = this._$AH;
    let s, n = 0;
    for (const o of t) n === i.length ? i.push(s = new kt(this.O(Tt()), this.O(Tt()), this, this.options)) : s = i[n], s._$AI(o), n++;
    n < i.length && (this._$AR(s && s._$AB.nextSibling, n), i.length = n);
  }
  _$AR(t = this._$AA.nextSibling, i) {
    var s;
    for ((s = this._$AP) == null ? void 0 : s.call(this, !1, !0, i); t !== this._$AB; ) {
      const n = t.nextSibling;
      t.remove(), t = n;
    }
  }
  setConnected(t) {
    var i;
    this._$AM === void 0 && (this._$Cv = t, (i = this._$AP) == null || i.call(this, t));
  }
}
class Wt {
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(t, i, s, n, o) {
    this.type = 1, this._$AH = _, this._$AN = void 0, this.element = t, this.name = i, this._$AM = n, this.options = o, s.length > 2 || s[0] !== "" || s[1] !== "" ? (this._$AH = Array(s.length - 1).fill(new String()), this.strings = s) : this._$AH = _;
  }
  _$AI(t, i = this, s, n) {
    const o = this.strings;
    let r = !1;
    if (o === void 0) t = vt(this, t, i, 0), r = !Vt(t) || t !== this._$AH && t !== ut, r && (this._$AH = t);
    else {
      const a = t;
      let l, h;
      for (t = o[0], l = 0; l < o.length - 1; l++) h = vt(this, a[s + l], i, l), h === ut && (h = this._$AH[l]), r || (r = !Vt(h) || h !== this._$AH[l]), h === _ ? t = _ : t !== _ && (t += (h ?? "") + o[l + 1]), this._$AH[l] = h;
    }
    r && !n && this.j(t);
  }
  j(t) {
    t === _ ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t ?? "");
  }
}
class Oi extends Wt {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(t) {
    this.element[this.name] = t === _ ? void 0 : t;
  }
}
class Di extends Wt {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(t) {
    this.element.toggleAttribute(this.name, !!t && t !== _);
  }
}
class Mi extends Wt {
  constructor(t, i, s, n, o) {
    super(t, i, s, n, o), this.type = 5;
  }
  _$AI(t, i = this) {
    if ((t = vt(this, t, i, 0) ?? _) === ut) return;
    const s = this._$AH, n = t === _ && s !== _ || t.capture !== s.capture || t.once !== s.once || t.passive !== s.passive, o = t !== _ && (s === _ || n);
    n && this.element.removeEventListener(this.name, this, s), o && this.element.addEventListener(this.name, this, t), this._$AH = t;
  }
  handleEvent(t) {
    var i;
    typeof this._$AH == "function" ? this._$AH.call(((i = this.options) == null ? void 0 : i.host) ?? this.element, t) : this._$AH.handleEvent(t);
  }
}
class Li {
  constructor(t, i, s) {
    this.element = t, this.type = 6, this._$AN = void 0, this._$AM = i, this.options = s;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t) {
    vt(this, t);
  }
}
const te = _t.litHtmlPolyfillSupport;
te == null || te(Rt, kt), (_t.litHtmlVersions ?? (_t.litHtmlVersions = [])).push("3.3.1");
const zi = (e, t, i) => {
  const s = (i == null ? void 0 : i.renderBefore) ?? t;
  let n = s._$litPart$;
  if (n === void 0) {
    const o = (i == null ? void 0 : i.renderBefore) ?? null;
    s._$litPart$ = n = new kt(t.insertBefore(Tt(), o), o, void 0, i ?? {});
  }
  return n._$AI(e), n;
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const ht = globalThis;
let mt = class extends pt {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;
  }
  createRenderRoot() {
    var i;
    const t = super.createRenderRoot();
    return (i = this.renderOptions).renderBefore ?? (i.renderBefore = t.firstChild), t;
  }
  update(t) {
    const i = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t), this._$Do = zi(i, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    var t;
    super.connectedCallback(), (t = this._$Do) == null || t.setConnected(!0);
  }
  disconnectedCallback() {
    var t;
    super.disconnectedCallback(), (t = this._$Do) == null || t.setConnected(!1);
  }
  render() {
    return ut;
  }
};
var We;
mt._$litElement$ = !0, mt.finalized = !0, (We = ht.litElementHydrateSupport) == null || We.call(ht, { LitElement: mt });
const ee = ht.litElementPolyfillSupport;
ee == null || ee({ LitElement: mt });
(ht.litElementVersions ?? (ht.litElementVersions = [])).push("4.2.1");
/*! Copyright 2025 Fonticons, Inc. - https://webawesome.com/license */
function Fi(e, t) {
  const i = e.metaKey || e.ctrlKey || e.shiftKey || e.altKey;
  e.key === "Enter" && !i && setTimeout(() => {
    !e.defaultPrevented && !e.isComposing && Bi(t);
  });
}
function Bi(e) {
  let t = null;
  if ("form" in e && (t = e.form), !t && "getForm" in e && (t = e.getForm()), !t)
    return;
  const i = [...t.elements];
  if (i.length === 1) {
    t.requestSubmit(null);
    return;
  }
  const s = i.find((n) => n.type === "submit" && !n.matches(":disabled"));
  s && (["input", "button"].includes(s.localName) ? t.requestSubmit(s) : s.click());
}
/*! Copyright 2025 Fonticons, Inc. - https://webawesome.com/license */
var Ni = `:host {
  display: flex;
  flex-direction: column;
}

/* Label */
:is([part~='form-control-label'], [part~='label']):has(*:not(:empty)) {
  display: inline-flex;
  color: var(--wa-form-control-label-color);
  font-weight: var(--wa-form-control-label-font-weight);
  line-height: var(--wa-form-control-label-line-height);
  margin-block-end: 0.5em;
}

:host([required]) :is([part~='form-control-label'], [part~='label'])::after {
  content: var(--wa-form-control-required-content);
  margin-inline-start: var(--wa-form-control-required-content-offset);
  color: var(--wa-form-control-required-content-color);
}

/* Help text */
[part~='hint'] {
  display: block;
  color: var(--wa-form-control-hint-color);
  font-weight: var(--wa-form-control-hint-font-weight);
  line-height: var(--wa-form-control-hint-line-height);
  margin-block-start: 0.5em;
  font-size: var(--wa-font-size-smaller);
  line-height: var(--wa-form-control-label-line-height);

  &:not(.has-slotted) {
    display: none;
  }
}
`;
/*! Copyright 2025 Fonticons, Inc. - https://webawesome.com/license */
var X = typeof window < "u" && "ontouchstart" in window, Ot = class {
  constructor(e, t) {
    this.isActive = !1, this.isDragging = !1, this.handleDragStart = (i) => {
      const s = X && "touches" in i ? i.touches[0].clientX : i.clientX, n = X && "touches" in i ? i.touches[0].clientY : i.clientY;
      this.isDragging || // Prevent right-clicks from triggering drags
      !X && i.buttons > 1 || (this.isDragging = !0, document.addEventListener("pointerup", this.handleDragStop), document.addEventListener("pointermove", this.handleDragMove), document.addEventListener("touchend", this.handleDragStop), document.addEventListener("touchmove", this.handleDragMove), this.options.start(s, n));
    }, this.handleDragStop = (i) => {
      const s = X && "touches" in i ? i.touches[0].clientX : i.clientX, n = X && "touches" in i ? i.touches[0].clientY : i.clientY;
      this.isDragging = !1, document.removeEventListener("pointerup", this.handleDragStop), document.removeEventListener("pointermove", this.handleDragMove), document.removeEventListener("touchend", this.handleDragStop), document.removeEventListener("touchmove", this.handleDragMove), this.options.stop(s, n);
    }, this.handleDragMove = (i) => {
      var o;
      const s = X && "touches" in i ? i.touches[0].clientX : i.clientX, n = X && "touches" in i ? i.touches[0].clientY : i.clientY;
      (o = window.getSelection()) == null || o.removeAllRanges(), this.options.move(s, n);
    }, this.element = e, this.options = {
      start: () => {
      },
      stop: () => {
      },
      move: () => {
      },
      ...t
    }, this.start();
  }
  /** Start listening to drags. */
  start() {
    this.isActive || (this.element.addEventListener("pointerdown", this.handleDragStart), X && this.element.addEventListener("touchstart", this.handleDragStart), this.isActive = !0);
  }
  /** Stop listening to drags. */
  stop() {
    document.removeEventListener("pointerup", this.handleDragStop), document.removeEventListener("pointermove", this.handleDragMove), document.removeEventListener("touchend", this.handleDragStop), document.removeEventListener("touchmove", this.handleDragMove), this.element.removeEventListener("pointerdown", this.handleDragStart), X && this.element.removeEventListener("touchstart", this.handleDragStart), this.isActive = !1, this.isDragging = !1;
  }
  /** Starts or stops the drag listeners. */
  toggle(e) {
    (e !== void 0 ? e : !this.isActive) ? this.start() : this.stop();
  }
};
/*! Copyright 2025 Fonticons, Inc. - https://webawesome.com/license */
var Ui = Object.defineProperty, Hi = Object.getOwnPropertyDescriptor, Je = (e) => {
  throw TypeError(e);
}, p = (e, t, i, s) => {
  for (var n = s > 1 ? void 0 : s ? Hi(t, i) : t, o = e.length - 1, r; o >= 0; o--)
    (r = e[o]) && (n = (s ? r(t, i, n) : r(n)) || n);
  return s && n && Ui(t, i, n), n;
}, Qe = (e, t, i) => t.has(e) || Je("Cannot " + i), Ii = (e, t, i) => (Qe(e, t, "read from private field"), t.get(e)), Wi = (e, t, i) => t.has(e) ? Je("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(e) : t.set(e, i), qi = (e, t, i, s) => (Qe(e, t, "write to private field"), t.set(e, i), i);
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const fe = (e) => (t, i) => {
  i !== void 0 ? i.addInitializer(() => {
    customElements.define(e, t);
  }) : customElements.define(e, t);
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const ji = { attribute: !0, type: String, converter: Bt, reflect: !1, hasChanged: de }, Ki = (e = ji, t, i) => {
  const { kind: s, metadata: n } = i;
  let o = globalThis.litPropertyMetadata.get(n);
  if (o === void 0 && globalThis.litPropertyMetadata.set(n, o = /* @__PURE__ */ new Map()), s === "setter" && ((e = Object.create(e)).wrapped = !0), o.set(i.name, e), s === "accessor") {
    const { name: r } = i;
    return { set(a) {
      const l = t.get.call(this);
      t.set.call(this, a), this.requestUpdate(r, l, e);
    }, init(a) {
      return a !== void 0 && this.C(r, void 0, e, a), a;
    } };
  }
  if (s === "setter") {
    const { name: r } = i;
    return function(a) {
      const l = this[r];
      t.call(this, a), this.requestUpdate(r, l, e);
    };
  }
  throw Error("Unsupported decorator location: " + s);
};
function m(e) {
  return (t, i) => typeof i == "object" ? Ki(e, t, i) : ((s, n, o) => {
    const r = n.hasOwnProperty(o);
    return n.constructor.createProperty(o, s), r ? Object.getOwnPropertyDescriptor(n, o) : void 0;
  })(e, t, i);
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function ti(e) {
  return m({ ...e, state: !0, attribute: !1 });
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Xi = (e, t, i) => (i.configurable = !0, i.enumerable = !0, Reflect.decorate && typeof t != "object" && Object.defineProperty(e, t, i), i);
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function N(e, t) {
  return (i, s, n) => {
    const o = (r) => {
      var a;
      return ((a = r.renderRoot) == null ? void 0 : a.querySelector(e)) ?? null;
    };
    return Xi(i, s, { get() {
      return o(this);
    } });
  };
}
/*! Copyright 2025 Fonticons, Inc. - https://webawesome.com/license */
var Yi = `:host {
  box-sizing: border-box !important;
}

:host *,
:host *::before,
:host *::after {
  box-sizing: inherit !important;
}

[hidden] {
  display: none !important;
}
`, zt, xt = class extends mt {
  constructor() {
    super(), Wi(this, zt, !1), this.initialReflectedProperties = /* @__PURE__ */ new Map(), this.didSSR = !!this.shadowRoot, this.customStates = {
      /** Adds or removes the specified custom state. */
      set: (t, i) => {
        var s;
        if ((s = this.internals) != null && s.states)
          try {
            i ? this.internals.states.add(t) : this.internals.states.delete(t);
          } catch (n) {
            if (String(n).includes("must start with '--'"))
              console.error("Your browser implements an outdated version of CustomStateSet. Consider using a polyfill");
            else
              throw n;
          }
      },
      /** Determines whether or not the element currently has the specified state. */
      has: (t) => {
        var i;
        if (!((i = this.internals) != null && i.states)) return !1;
        try {
          return this.internals.states.has(t);
        } catch {
          return !1;
        }
      }
    };
    try {
      this.internals = this.attachInternals();
    } catch {
      console.error("Element internals are not supported in your browser. Consider using a polyfill");
    }
    this.customStates.set("wa-defined", !0);
    let e = this.constructor;
    for (let [t, i] of e.elementProperties)
      i.default === "inherit" && i.initial !== void 0 && typeof t == "string" && this.customStates.set(`initial-${t}-${i.initial}`, !0);
  }
  /**
   * Override the default styles property to fetch and convert string CSS files. Components can override this behavior
   * by setting their own `static styles = []` property.
   */
  static get styles() {
    const e = Array.isArray(this.css) ? this.css : this.css ? [this.css] : [];
    return [Yi, ...e].map((t) => typeof t == "string" ? Ke(t) : t);
  }
  attributeChangedCallback(e, t, i) {
    Ii(this, zt) || (this.constructor.elementProperties.forEach(
      (s, n) => {
        s.reflect && this[n] != null && this.initialReflectedProperties.set(n, this[n]);
      }
    ), qi(this, zt, !0)), super.attributeChangedCallback(e, t, i);
  }
  willUpdate(e) {
    super.willUpdate(e), this.initialReflectedProperties.forEach((t, i) => {
      e.has(i) && this[i] == null && (this[i] = t);
    });
  }
  firstUpdated(e) {
    var t;
    super.firstUpdated(e), this.didSSR && ((t = this.shadowRoot) == null || t.querySelectorAll("slot").forEach((i) => {
      i.dispatchEvent(new Event("slotchange", { bubbles: !0, composed: !1, cancelable: !1 }));
    }));
  }
  update(e) {
    try {
      super.update(e);
    } catch (t) {
      if (this.didSSR && !this.hasUpdated) {
        const i = new Event("lit-hydration-error", { bubbles: !0, composed: !0, cancelable: !1 });
        i.error = t, this.dispatchEvent(i);
      }
      throw t;
    }
  }
  /**
   * Given a native event, this function cancels it and dispatches it again from the host element using the desired
   * event options.
   */
  relayNativeEvent(e, t) {
    e.stopImmediatePropagation(), this.dispatchEvent(
      new e.constructor(e.type, {
        ...e,
        ...t
      })
    );
  }
};
zt = /* @__PURE__ */ new WeakMap();
p([
  m()
], xt.prototype, "dir", 2);
p([
  m()
], xt.prototype, "lang", 2);
p([
  m({ type: Boolean, reflect: !0, attribute: "did-ssr" })
], xt.prototype, "didSSR", 2);
/*! Copyright 2025 Fonticons, Inc. - https://webawesome.com/license */
var Zi = class extends Event {
  constructor() {
    super("wa-invalid", { bubbles: !0, cancelable: !1, composed: !0 });
  }
}, Gi = () => ({
  observedAttributes: ["custom-error"],
  checkValidity(e) {
    const t = {
      message: "",
      isValid: !0,
      invalidKeys: []
    };
    return e.customError && (t.message = e.customError, t.isValid = !1, t.invalidKeys = ["customError"]), t;
  }
}), nt = class extends xt {
  constructor() {
    super(), this.name = null, this.disabled = !1, this.required = !1, this.assumeInteractionOn = ["input"], this.validators = [], this.valueHasChanged = !1, this.hasInteracted = !1, this.customError = null, this.emittedEvents = [], this.emitInvalid = (e) => {
      e.target === this && (this.hasInteracted = !0, this.dispatchEvent(new Zi()));
    }, this.handleInteraction = (e) => {
      var i;
      const t = this.emittedEvents;
      t.includes(e.type) || t.push(e.type), t.length === ((i = this.assumeInteractionOn) == null ? void 0 : i.length) && (this.hasInteracted = !0);
    }, this.addEventListener("invalid", this.emitInvalid);
  }
  /**
   * Validators are static because they have `observedAttributes`, essentially attributes to "watch"
   * for changes. Whenever these attributes change, we want to be notified and update the validator.
   */
  static get validators() {
    return [Gi()];
  }
  // Append all Validator "observedAttributes" into the "observedAttributes" so they can run.
  static get observedAttributes() {
    const e = new Set(super.observedAttributes || []);
    for (const t of this.validators)
      if (t.observedAttributes)
        for (const i of t.observedAttributes)
          e.add(i);
    return [...e];
  }
  connectedCallback() {
    super.connectedCallback(), this.updateValidity(), this.assumeInteractionOn.forEach((e) => {
      this.addEventListener(e, this.handleInteraction);
    });
  }
  firstUpdated(...e) {
    super.firstUpdated(...e), this.updateValidity();
  }
  willUpdate(e) {
    if (e.has("customError") && (this.customError || (this.customError = null), this.setCustomValidity(this.customError || "")), e.has("value") || e.has("disabled")) {
      const t = this.value;
      if (Array.isArray(t)) {
        if (this.name) {
          const i = new FormData();
          for (const s of t)
            i.append(this.name, s);
          this.setValue(i, i);
        }
      } else
        this.setValue(t, t);
    }
    e.has("disabled") && (this.customStates.set("disabled", this.disabled), (this.hasAttribute("disabled") || !this.matches(":disabled")) && this.toggleAttribute("disabled", this.disabled)), this.updateValidity(), super.willUpdate(e);
  }
  get labels() {
    return this.internals.labels;
  }
  getForm() {
    return this.internals.form;
  }
  get validity() {
    return this.internals.validity;
  }
  // Not sure if this supports `novalidate`. Will need to test.
  get willValidate() {
    return this.internals.willValidate;
  }
  get validationMessage() {
    return this.internals.validationMessage;
  }
  checkValidity() {
    return this.updateValidity(), this.internals.checkValidity();
  }
  reportValidity() {
    return this.updateValidity(), this.hasInteracted = !0, this.internals.reportValidity();
  }
  /**
   * Override this to change where constraint validation popups are anchored.
   */
  get validationTarget() {
    return this.input || void 0;
  }
  setValidity(...e) {
    const t = e[0], i = e[1];
    let s = e[2];
    s || (s = this.validationTarget), this.internals.setValidity(t, i, s || void 0), this.requestUpdate("validity"), this.setCustomStates();
  }
  setCustomStates() {
    const e = !!this.required, t = this.internals.validity.valid, i = this.hasInteracted;
    this.customStates.set("required", e), this.customStates.set("optional", !e), this.customStates.set("invalid", !t), this.customStates.set("valid", t), this.customStates.set("user-invalid", !t && i), this.customStates.set("user-valid", t && i);
  }
  /**
   * Do not use this when creating a "Validator". This is intended for end users of components.
   * We track manually defined custom errors so we don't clear them on accident in our validators.
   *
   */
  setCustomValidity(e) {
    if (!e) {
      this.customError = null, this.setValidity({});
      return;
    }
    this.customError = e, this.setValidity({ customError: !0 }, e, this.validationTarget);
  }
  formResetCallback() {
    this.resetValidity(), this.hasInteracted = !1, this.valueHasChanged = !1, this.emittedEvents = [], this.updateValidity();
  }
  formDisabledCallback(e) {
    this.disabled = e, this.updateValidity();
  }
  /**
   * Called when the browser is trying to restore elements state to state in which case reason is "restore", or when
   * the browser is trying to fulfill autofill on behalf of user in which case reason is "autocomplete". In the case of
   * "restore", state is a string, File, or FormData object previously set as the second argument to setFormValue.
   */
  formStateRestoreCallback(e, t) {
    this.value = e, t === "restore" && this.resetValidity(), this.updateValidity();
  }
  setValue(...e) {
    const [t, i] = e;
    this.internals.setFormValue(t, i);
  }
  get allValidators() {
    const e = this.constructor.validators || [], t = this.validators || [];
    return [...e, ...t];
  }
  /**
   * Reset validity is a way of removing manual custom errors and native validation.
   */
  resetValidity() {
    this.setCustomValidity(""), this.setValidity({});
  }
  updateValidity() {
    if (this.disabled || this.hasAttribute("disabled") || !this.willValidate) {
      this.resetValidity();
      return;
    }
    const e = this.allValidators;
    if (!(e != null && e.length))
      return;
    const t = {
      // Don't trust custom errors from the Browser. Safari breaks the spec.
      customError: !!this.customError
    }, i = this.validationTarget || this.input || void 0;
    let s = "";
    for (const n of e) {
      const { isValid: o, message: r, invalidKeys: a } = n.checkValidity(this);
      o || (s || (s = r), (a == null ? void 0 : a.length) >= 0 && a.forEach((l) => t[l] = !0));
    }
    s || (s = this.validationMessage), this.setValidity(t, s, i);
  }
};
nt.formAssociated = !0;
p([
  m({ reflect: !0 })
], nt.prototype, "name", 2);
p([
  m({ type: Boolean })
], nt.prototype, "disabled", 2);
p([
  m({ state: !0, attribute: !1 })
], nt.prototype, "valueHasChanged", 2);
p([
  m({ state: !0, attribute: !1 })
], nt.prototype, "hasInteracted", 2);
p([
  m({ attribute: "custom-error", reflect: !0 })
], nt.prototype, "customError", 2);
p([
  m({ attribute: !1, state: !0, type: Object })
], nt.prototype, "validity", 1);
/*! Copyright 2025 Fonticons, Inc. - https://webawesome.com/license */
var Ji = class {
  constructor(e, ...t) {
    this.slotNames = [], this.handleSlotChange = (i) => {
      const s = i.target;
      (this.slotNames.includes("[default]") && !s.name || s.name && this.slotNames.includes(s.name)) && this.host.requestUpdate();
    }, (this.host = e).addController(this), this.slotNames = t;
  }
  hasDefaultSlot() {
    return [...this.host.childNodes].some((e) => {
      if (e.nodeType === Node.TEXT_NODE && e.textContent.trim() !== "")
        return !0;
      if (e.nodeType === Node.ELEMENT_NODE) {
        const t = e;
        if (t.tagName.toLowerCase() === "wa-visually-hidden")
          return !1;
        if (!t.hasAttribute("slot"))
          return !0;
      }
      return !1;
    });
  }
  hasNamedSlot(e) {
    return this.host.querySelector(`:scope > [slot="${e}"]`) !== null;
  }
  test(e) {
    return e === "[default]" ? this.hasDefaultSlot() : this.hasNamedSlot(e);
  }
  hostConnected() {
    this.host.shadowRoot.addEventListener("slotchange", this.handleSlotChange);
  }
  hostDisconnected() {
    this.host.shadowRoot.removeEventListener("slotchange", this.handleSlotChange);
  }
};
/*! Copyright 2025 Fonticons, Inc. - https://webawesome.com/license */
var Qi = `@layer wa-utilities {
  :host([size='small']),
  .wa-size-s {
    font-size: var(--wa-font-size-s);
  }

  :host([size='medium']),
  .wa-size-m {
    font-size: var(--wa-font-size-m);
  }

  :host([size='large']),
  .wa-size-l {
    font-size: var(--wa-font-size-l);
  }
}
`;
const ts = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
let es = (e = 21) => {
  let t = "", i = crypto.getRandomValues(new Uint8Array(e |= 0));
  for (; e--; )
    t += ts[i[e] & 63];
  return t;
};
/*! Copyright 2025 Fonticons, Inc. - https://webawesome.com/license */
function R(e, t, i) {
  const s = (n) => Object.is(n, -0) ? 0 : n;
  return e < t ? s(t) : e > i ? s(i) : s(e);
}
function is(e = "") {
  return `${e}${es()}`;
}
const ne = /* @__PURE__ */ new Set(), ft = /* @__PURE__ */ new Map();
let at, me = "ltr", ge = "en";
const ei = typeof MutationObserver < "u" && typeof document < "u" && typeof document.documentElement < "u";
if (ei) {
  const e = new MutationObserver(si);
  me = document.documentElement.dir || "ltr", ge = document.documentElement.lang || navigator.language, e.observe(document.documentElement, {
    attributes: !0,
    attributeFilter: ["dir", "lang"]
  });
}
function ii(...e) {
  e.map((t) => {
    const i = t.$code.toLowerCase();
    ft.has(i) ? ft.set(i, Object.assign(Object.assign({}, ft.get(i)), t)) : ft.set(i, t), at || (at = t);
  }), si();
}
function si() {
  ei && (me = document.documentElement.dir || "ltr", ge = document.documentElement.lang || navigator.language), [...ne.keys()].map((e) => {
    typeof e.requestUpdate == "function" && e.requestUpdate();
  });
}
let ss = class {
  constructor(t) {
    this.host = t, this.host.addController(this);
  }
  hostConnected() {
    ne.add(this.host);
  }
  hostDisconnected() {
    ne.delete(this.host);
  }
  dir() {
    return `${this.host.dir || me}`.toLowerCase();
  }
  lang() {
    return `${this.host.lang || ge}`.toLowerCase();
  }
  getTranslationData(t) {
    var i, s;
    const n = new Intl.Locale(t.replace(/_/g, "-")), o = n == null ? void 0 : n.language.toLowerCase(), r = (s = (i = n == null ? void 0 : n.region) === null || i === void 0 ? void 0 : i.toLowerCase()) !== null && s !== void 0 ? s : "", a = ft.get(`${o}-${r}`), l = ft.get(o);
    return { locale: n, language: o, region: r, primary: a, secondary: l };
  }
  exists(t, i) {
    var s;
    const { primary: n, secondary: o } = this.getTranslationData((s = i.lang) !== null && s !== void 0 ? s : this.lang());
    return i = Object.assign({ includeFallback: !1 }, i), !!(n && n[t] || o && o[t] || i.includeFallback && at && at[t]);
  }
  term(t, ...i) {
    const { primary: s, secondary: n } = this.getTranslationData(this.lang());
    let o;
    if (s && s[t])
      o = s[t];
    else if (n && n[t])
      o = n[t];
    else if (at && at[t])
      o = at[t];
    else
      return console.error(`No translation found for: ${String(t)}`), String(t);
    return typeof o == "function" ? o(...i) : o;
  }
  date(t, i) {
    return t = new Date(t), new Intl.DateTimeFormat(this.lang(), i).format(t);
  }
  number(t, i) {
    return t = Number(t), isNaN(t) ? "" : new Intl.NumberFormat(this.lang(), i).format(t);
  }
  relativeTime(t, i, s) {
    return new Intl.RelativeTimeFormat(this.lang(), s).format(t, i);
  }
};
/*! Copyright 2025 Fonticons, Inc. - https://webawesome.com/license */
var ni = {
  $code: "en",
  $name: "English",
  $dir: "ltr",
  carousel: "Carousel",
  clearEntry: "Clear entry",
  close: "Close",
  copied: "Copied",
  copy: "Copy",
  currentValue: "Current value",
  error: "Error",
  goToSlide: (e, t) => `Go to slide ${e} of ${t}`,
  hidePassword: "Hide password",
  loading: "Loading",
  nextSlide: "Next slide",
  numOptionsSelected: (e) => e === 0 ? "No options selected" : e === 1 ? "1 option selected" : `${e} options selected`,
  pauseAnimation: "Pause animation",
  playAnimation: "Play animation",
  previousSlide: "Previous slide",
  progress: "Progress",
  remove: "Remove",
  resize: "Resize",
  scrollableRegion: "Scrollable region",
  scrollToEnd: "Scroll to end",
  scrollToStart: "Scroll to start",
  selectAColorFromTheScreen: "Select a color from the screen",
  showPassword: "Show password",
  slideNum: (e) => `Slide ${e}`,
  toggleColorFormat: "Toggle color format",
  zoomIn: "Zoom in",
  zoomOut: "Zoom out"
};
ii(ni);
var ns = ni;
/*! Copyright 2025 Fonticons, Inc. - https://webawesome.com/license */
var oi = class extends ss {
};
ii(ns);
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const os = { ATTRIBUTE: 1 }, rs = (e) => (...t) => ({ _$litDirective$: e, values: t });
let as = class {
  constructor(t) {
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AT(t, i, s) {
    this._$Ct = t, this._$AM = i, this._$Ci = s;
  }
  _$AS(t, i) {
    return this.update(t, i);
  }
  update(t, i) {
    return this.render(...i);
  }
};
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const gt = rs(class extends as {
  constructor(e) {
    var t;
    if (super(e), e.type !== os.ATTRIBUTE || e.name !== "class" || ((t = e.strings) == null ? void 0 : t.length) > 2) throw Error("`classMap()` can only be used in the `class` attribute and must be the only part in the attribute.");
  }
  render(e) {
    return " " + Object.keys(e).filter((t) => e[t]).join(" ") + " ";
  }
  update(e, [t]) {
    var s, n;
    if (this.st === void 0) {
      this.st = /* @__PURE__ */ new Set(), e.strings !== void 0 && (this.nt = new Set(e.strings.join(" ").split(/\s/).filter((o) => o !== "")));
      for (const o in t) t[o] && !((s = this.nt) != null && s.has(o)) && this.st.add(o);
      return this.render(t);
    }
    const i = e.element.classList;
    for (const o of this.st) o in t || (i.remove(o), this.st.delete(o));
    for (const o in t) {
      const r = !!t[o];
      r === this.st.has(o) || (n = this.nt) != null && n.has(o) || (r ? (i.add(o), this.st.add(o)) : (i.remove(o), this.st.delete(o)));
    }
    return ut;
  }
});
/*! Copyright 2025 Fonticons, Inc. - https://webawesome.com/license */
var ls = () => {
  const e = Object.assign(document.createElement("input"), {
    type: "range",
    required: !0
  });
  return {
    observedAttributes: ["required", "min", "max", "step"],
    checkValidity(t) {
      const i = {
        message: "",
        isValid: !0,
        invalidKeys: []
      }, s = (n, o, r, a) => {
        const l = document.createElement("input");
        return l.type = "range", l.min = String(o), l.max = String(r), l.step = String(a), l.value = String(n), l.checkValidity(), l.validationMessage;
      };
      if (t.required && !t.hasInteracted)
        return i.isValid = !1, i.invalidKeys.push("valueMissing"), i.message = e.validationMessage || "Please fill out this field.", i;
      if (t.isRange) {
        const n = t.minValue, o = t.maxValue;
        if (n < t.min)
          return i.isValid = !1, i.invalidKeys.push("rangeUnderflow"), i.message = s(n, t.min, t.max, t.step) || `Value must be greater than or equal to ${t.min}.`, i;
        if (o > t.max)
          return i.isValid = !1, i.invalidKeys.push("rangeOverflow"), i.message = s(o, t.min, t.max, t.step) || `Value must be less than or equal to ${t.max}.`, i;
        if (t.step && t.step !== 1) {
          const r = (n - t.min) % t.step !== 0, a = (o - t.min) % t.step !== 0;
          if (r || a) {
            i.isValid = !1, i.invalidKeys.push("stepMismatch");
            const l = r ? n : o;
            return i.message = s(l, t.min, t.max, t.step) || `Value must be a multiple of ${t.step}.`, i;
          }
        }
      } else {
        const n = t.value;
        if (n < t.min)
          return i.isValid = !1, i.invalidKeys.push("rangeUnderflow"), i.message = s(n, t.min, t.max, t.step) || `Value must be greater than or equal to ${t.min}.`, i;
        if (n > t.max)
          return i.isValid = !1, i.invalidKeys.push("rangeOverflow"), i.message = s(n, t.min, t.max, t.step) || `Value must be less than or equal to ${t.max}.`, i;
        if (t.step && t.step !== 1 && (n - t.min) % t.step !== 0)
          return i.isValid = !1, i.invalidKeys.push("stepMismatch"), i.message = s(n, t.min, t.max, t.step) || `Value must be a multiple of ${t.step}.`, i;
      }
      return i;
    }
  };
}, hs = `:host {
  --track-size: 0.5em;
  --thumb-width: 1.4em;
  --thumb-height: 1.4em;
  --marker-width: 0.1875em;
  --marker-height: 0.1875em;
}

:host([orientation='vertical']) {
  width: auto;
}

#label:has(~ .vertical) {
  display: block;
  order: 2;
  max-width: none;
  text-align: center;
}

#description:has(~ .vertical) {
  order: 3;
  text-align: center;
}

/* Add extra space between slider and label, when present */
#label:has(*:not(:empty)) ~ #slider {
  &.horizontal {
    margin-block-start: 0.5em;
  }
  &.vertical {
    margin-block-end: 0.5em;
  }
}

#slider {
  touch-action: none;

  &:focus {
    outline: none;
  }

  &:focus-visible:not(.disabled) #thumb,
  &:focus-visible:not(.disabled) #thumb-min,
  &:focus-visible:not(.disabled) #thumb-max {
    outline: var(--wa-focus-ring);
    /* intentionally no offset due to border */
  }
}

#track {
  position: relative;
  border-radius: 9999px;
  background: var(--wa-color-neutral-fill-normal);
  isolation: isolate;
}

/* Orientation */
.horizontal #track {
  height: var(--track-size);
}

.vertical #track {
  order: 1;
  width: var(--track-size);
  height: 200px;
}

/* Disabled */
.disabled #track {
  cursor: not-allowed;
  opacity: 0.5;
}

/* Indicator */
#indicator {
  position: absolute;
  border-radius: inherit;
  background-color: var(--wa-form-control-activated-color);

  &:dir(ltr) {
    right: calc(100% - max(var(--start), var(--end)));
    left: min(var(--start), var(--end));
  }

  &:dir(rtl) {
    right: min(var(--start), var(--end));
    left: calc(100% - max(var(--start), var(--end)));
  }
}

.horizontal #indicator {
  top: 0;
  height: 100%;
}

.vertical #indicator {
  top: calc(100% - var(--end));
  bottom: var(--start);
  left: 0;
  width: 100%;
}

/* Thumbs */
#thumb,
#thumb-min,
#thumb-max {
  z-index: 3;
  position: absolute;
  width: var(--thumb-width);
  height: var(--thumb-height);
  border: solid 0.125em var(--wa-color-surface-default);
  border-radius: 50%;
  background-color: var(--wa-form-control-activated-color);
  cursor: pointer;
}

.disabled #thumb,
.disabled #thumb-min,
.disabled #thumb-max {
  cursor: inherit;
}

.horizontal #thumb,
.horizontal #thumb-min,
.horizontal #thumb-max {
  top: calc(50% - var(--thumb-height) / 2);

  &:dir(ltr) {
    right: auto;
    left: calc(var(--position) - var(--thumb-width) / 2);
  }

  &:dir(rtl) {
    right: calc(var(--position) - var(--thumb-width) / 2);
    left: auto;
  }
}

.vertical #thumb,
.vertical #thumb-min,
.vertical #thumb-max {
  bottom: calc(var(--position) - var(--thumb-height) / 2);
  left: calc(50% - var(--thumb-width) / 2);
}

/* Range-specific thumb styles */
:host([range]) {
  #thumb-min:focus-visible,
  #thumb-max:focus-visible {
    z-index: 4; /* Ensure focused thumb appears on top */
    outline: var(--wa-focus-ring);
    /* intentionally no offset due to border */
  }
}

/* Markers */
#markers {
  pointer-events: none;
}

.marker {
  z-index: 2;
  position: absolute;
  width: var(--marker-width);
  height: var(--marker-height);
  border-radius: 50%;
  background-color: var(--wa-color-surface-default);
}

.marker:first-of-type,
.marker:last-of-type {
  display: none;
}

.horizontal .marker {
  top: calc(50% - var(--marker-height) / 2);
  left: calc(var(--position) - var(--marker-width) / 2);
}

.vertical .marker {
  top: calc(var(--position) - var(--marker-height) / 2);
  left: calc(50% - var(--marker-width) / 2);
}

/* Marker labels */
#references {
  position: relative;

  slot {
    display: flex;
    justify-content: space-between;
    height: 100%;
  }

  ::slotted(*) {
    color: var(--wa-color-text-quiet);
    font-size: 0.875em;
    line-height: 1;
  }
}

.horizontal {
  #references {
    margin-block-start: 0.5em;
  }
}

.vertical {
  display: flex;
  margin-inline: auto;

  #track {
    order: 1;
  }

  #references {
    order: 2;
    width: min-content;
    margin-inline-start: 0.75em;

    slot {
      flex-direction: column;
    }
  }
}

.vertical #references slot {
  flex-direction: column;
}
`, y = class extends nt {
  constructor() {
    super(...arguments), this.draggableThumbMin = null, this.draggableThumbMax = null, this.hasSlotController = new Ji(this, "hint", "label"), this.localize = new oi(this), this.activeThumb = null, this.lastTrackPosition = null, this.label = "", this.hint = "", this.minValue = 0, this.maxValue = 50, this.defaultValue = this.getAttribute("value") == null ? this.minValue : Number(this.getAttribute("value")), this._value = this.defaultValue, this.range = !1, this.disabled = !1, this.readonly = !1, this.orientation = "horizontal", this.size = "medium", this.form = null, this.min = 0, this.max = 100, this.step = 1, this.required = !1, this.tooltipDistance = 8, this.tooltipPlacement = "top", this.withMarkers = !1, this.withTooltip = !1;
  }
  static get validators() {
    return [...super.validators, ls()];
  }
  // Track last position for direction detection
  get focusableAnchor() {
    return this.isRange ? this.thumbMin || this.slider : this.slider;
  }
  /** Override validation target to point to the focusable element */
  get validationTarget() {
    return this.focusableAnchor;
  }
  /** The current value of the slider, submitted as a name/value pair with form data. */
  get value() {
    return this.valueHasChanged ? this._value : this._value ?? this.defaultValue;
  }
  set value(e) {
    e = Number(e) ?? this.minValue, this._value !== e && (this.valueHasChanged = !0, this._value = e);
  }
  /** Get if this is a range slider */
  get isRange() {
    return this.range;
  }
  firstUpdated() {
    this.isRange ? (this.draggableThumbMin = new Ot(this.thumbMin, {
      start: () => {
        this.activeThumb = "min", this.trackBoundingClientRect = this.track.getBoundingClientRect(), this.valueWhenDraggingStarted = this.minValue, this.customStates.set("dragging", !0), this.showRangeTooltips();
      },
      move: (e, t) => {
        this.setThumbValueFromCoordinates(e, t, "min");
      },
      stop: () => {
        this.minValue !== this.valueWhenDraggingStarted && (this.updateComplete.then(() => {
          this.dispatchEvent(new Event("change", { bubbles: !0, composed: !0 }));
        }), this.hasInteracted = !0), this.hideRangeTooltips(), this.customStates.set("dragging", !1), this.valueWhenDraggingStarted = void 0, this.activeThumb = null;
      }
    }), this.draggableThumbMax = new Ot(this.thumbMax, {
      start: () => {
        this.activeThumb = "max", this.trackBoundingClientRect = this.track.getBoundingClientRect(), this.valueWhenDraggingStarted = this.maxValue, this.customStates.set("dragging", !0), this.showRangeTooltips();
      },
      move: (e, t) => {
        this.setThumbValueFromCoordinates(e, t, "max");
      },
      stop: () => {
        this.maxValue !== this.valueWhenDraggingStarted && (this.updateComplete.then(() => {
          this.dispatchEvent(new Event("change", { bubbles: !0, composed: !0 }));
        }), this.hasInteracted = !0), this.hideRangeTooltips(), this.customStates.set("dragging", !1), this.valueWhenDraggingStarted = void 0, this.activeThumb = null;
      }
    }), this.draggableTrack = new Ot(this.track, {
      start: (e, t) => {
        if (this.trackBoundingClientRect = this.track.getBoundingClientRect(), this.activeThumb)
          this.valueWhenDraggingStarted = this.activeThumb === "min" ? this.minValue : this.maxValue;
        else {
          const i = this.getValueFromCoordinates(e, t), s = Math.abs(i - this.minValue), n = Math.abs(i - this.maxValue);
          if (s === n)
            if (i > this.maxValue)
              this.activeThumb = "max";
            else if (i < this.minValue)
              this.activeThumb = "min";
            else {
              const o = this.localize.dir() === "rtl", r = this.orientation === "vertical", a = r ? t : e, l = this.lastTrackPosition || a;
              this.lastTrackPosition = a;
              const h = a > l !== o && !r || a < l && r;
              this.activeThumb = h ? "max" : "min";
            }
          else
            this.activeThumb = s <= n ? "min" : "max";
          this.valueWhenDraggingStarted = this.activeThumb === "min" ? this.minValue : this.maxValue;
        }
        this.customStates.set("dragging", !0), this.setThumbValueFromCoordinates(e, t, this.activeThumb), this.showRangeTooltips();
      },
      move: (e, t) => {
        this.activeThumb && this.setThumbValueFromCoordinates(e, t, this.activeThumb);
      },
      stop: () => {
        this.activeThumb && (this.activeThumb === "min" ? this.minValue : this.maxValue) !== this.valueWhenDraggingStarted && (this.updateComplete.then(() => {
          this.dispatchEvent(new Event("change", { bubbles: !0, composed: !0 }));
        }), this.hasInteracted = !0), this.hideRangeTooltips(), this.customStates.set("dragging", !1), this.valueWhenDraggingStarted = void 0, this.activeThumb = null;
      }
    })) : this.draggableTrack = new Ot(this.slider, {
      start: (e, t) => {
        this.trackBoundingClientRect = this.track.getBoundingClientRect(), this.valueWhenDraggingStarted = this.value, this.customStates.set("dragging", !0), this.setValueFromCoordinates(e, t), this.showTooltip();
      },
      move: (e, t) => {
        this.setValueFromCoordinates(e, t);
      },
      stop: () => {
        this.value !== this.valueWhenDraggingStarted && (this.updateComplete.then(() => {
          this.dispatchEvent(new Event("change", { bubbles: !0, composed: !0 }));
        }), this.hasInteracted = !0), this.hideTooltip(), this.customStates.set("dragging", !1), this.valueWhenDraggingStarted = void 0;
      }
    });
  }
  updated(e) {
    if (e.has("range") && this.requestUpdate(), this.isRange ? (e.has("minValue") || e.has("maxValue")) && (this.minValue = R(this.minValue, this.min, this.maxValue), this.maxValue = R(this.maxValue, this.minValue, this.max), this.updateFormValue()) : e.has("value") && (this.value = R(this.value, this.min, this.max), this.setValue(String(this.value))), (e.has("min") || e.has("max")) && (this.isRange ? (this.minValue = R(this.minValue, this.min, this.max), this.maxValue = R(this.maxValue, this.min, this.max)) : this.value = R(this.value, this.min, this.max)), e.has("disabled") && this.customStates.set("disabled", this.disabled), e.has("disabled") || e.has("readonly")) {
      const t = !(this.disabled || this.readonly);
      this.isRange && (this.draggableThumbMin && this.draggableThumbMin.toggle(t), this.draggableThumbMax && this.draggableThumbMax.toggle(t)), this.draggableTrack && this.draggableTrack.toggle(t);
    }
    super.updated(e);
  }
  /** @internal Called when a containing fieldset is disabled. */
  formDisabledCallback(e) {
    this.disabled = e;
  }
  /** @internal Called when the form is reset. */
  formResetCallback() {
    this.isRange ? (this.minValue = parseFloat(this.getAttribute("min-value") ?? String(this.min)), this.maxValue = parseFloat(this.getAttribute("max-value") ?? String(this.max))) : this.value = parseFloat(this.getAttribute("value") ?? String(this.min)), this.hasInteracted = !1, super.formResetCallback();
  }
  /** Clamps a number to min/max while ensuring it's a valid step interval. */
  clampAndRoundToStep(e) {
    const t = (String(this.step).split(".")[1] || "").replace(/0+$/g, "").length;
    return e = Math.round(e / this.step) * this.step, e = R(e, this.min, this.max), parseFloat(e.toFixed(t));
  }
  /** Given a value, returns its percentage within a range of min/max. */
  getPercentageFromValue(e) {
    return (e - this.min) / (this.max - this.min) * 100;
  }
  /** Converts coordinates to slider value */
  getValueFromCoordinates(e, t) {
    const i = this.localize.dir() === "rtl", s = this.orientation === "vertical", { top: n, right: o, bottom: r, left: a, height: l, width: h } = this.trackBoundingClientRect, c = s ? t : e, u = s ? { start: n, end: r, size: l } : { start: a, end: o, size: h }, d = (s || i ? u.end - c : c - u.start) / u.size;
    return this.clampAndRoundToStep(this.min + (this.max - this.min) * d);
  }
  handleBlur() {
    this.isRange ? requestAnimationFrame(() => {
      var i;
      const e = (i = this.shadowRoot) == null ? void 0 : i.activeElement;
      e === this.thumbMin || e === this.thumbMax || this.hideRangeTooltips();
    }) : this.hideTooltip(), this.customStates.set("focused", !1), this.dispatchEvent(new FocusEvent("blur", { bubbles: !0, composed: !0 }));
  }
  handleFocus(e) {
    const t = e.target;
    this.isRange ? (t === this.thumbMin ? this.activeThumb = "min" : t === this.thumbMax && (this.activeThumb = "max"), this.showRangeTooltips()) : this.showTooltip(), this.customStates.set("focused", !0), this.dispatchEvent(new FocusEvent("focus", { bubbles: !0, composed: !0 }));
  }
  handleKeyDown(e) {
    const t = this.localize.dir() === "rtl", i = e.target;
    if (this.disabled || this.readonly || this.isRange && (i === this.thumbMin ? this.activeThumb = "min" : i === this.thumbMax && (this.activeThumb = "max"), !this.activeThumb))
      return;
    const s = this.isRange ? this.activeThumb === "min" ? this.minValue : this.maxValue : this.value;
    let n = s;
    switch (e.key) {
      case "ArrowUp":
      case (t ? "ArrowLeft" : "ArrowRight"):
        e.preventDefault(), n = this.clampAndRoundToStep(s + this.step);
        break;
      case "ArrowDown":
      case (t ? "ArrowRight" : "ArrowLeft"):
        e.preventDefault(), n = this.clampAndRoundToStep(s - this.step);
        break;
      case "Home":
        e.preventDefault(), n = this.isRange && this.activeThumb === "min" ? this.min : this.isRange ? this.minValue : this.min;
        break;
      case "End":
        e.preventDefault(), n = this.isRange && this.activeThumb === "max" ? this.max : this.isRange ? this.maxValue : this.max;
        break;
      case "PageUp":
        e.preventDefault();
        const o = Math.max(
          s + (this.max - this.min) / 10,
          s + this.step
          // make sure we at least move up to the next step
        );
        n = this.clampAndRoundToStep(o);
        break;
      case "PageDown":
        e.preventDefault();
        const r = Math.min(
          s - (this.max - this.min) / 10,
          s - this.step
          // make sure we at least move down to the previous step
        );
        n = this.clampAndRoundToStep(r);
        break;
      case "Enter":
        Fi(e, this);
        return;
    }
    n !== s && (this.isRange ? (this.activeThumb === "min" ? n > this.maxValue ? (this.maxValue = n, this.minValue = n) : this.minValue = Math.max(this.min, n) : n < this.minValue ? (this.minValue = n, this.maxValue = n) : this.maxValue = Math.min(this.max, n), this.updateFormValue()) : this.value = R(n, this.min, this.max), this.updateComplete.then(() => {
      this.dispatchEvent(new InputEvent("input", { bubbles: !0, composed: !0 })), this.dispatchEvent(new Event("change", { bubbles: !0, composed: !0 }));
    }), this.hasInteracted = !0);
  }
  handleLabelPointerDown(e) {
    var t;
    e.preventDefault(), this.disabled || (this.isRange ? (t = this.thumbMin) == null || t.focus() : this.slider.focus());
  }
  setValueFromCoordinates(e, t) {
    const i = this.value;
    this.value = this.getValueFromCoordinates(e, t), this.value !== i && this.updateComplete.then(() => {
      this.dispatchEvent(new InputEvent("input", { bubbles: !0, composed: !0 }));
    });
  }
  setThumbValueFromCoordinates(e, t, i) {
    const s = this.getValueFromCoordinates(e, t), n = i === "min" ? this.minValue : this.maxValue;
    i === "min" ? s > this.maxValue ? (this.maxValue = s, this.minValue = s) : this.minValue = Math.max(this.min, s) : s < this.minValue ? (this.minValue = s, this.maxValue = s) : this.maxValue = Math.min(this.max, s), n !== (i === "min" ? this.minValue : this.maxValue) && (this.updateFormValue(), this.updateComplete.then(() => {
      this.dispatchEvent(new InputEvent("input", { bubbles: !0, composed: !0 }));
    }));
  }
  showTooltip() {
    this.withTooltip && this.tooltip && (this.tooltip.open = !0);
  }
  hideTooltip() {
    this.withTooltip && this.tooltip && (this.tooltip.open = !1);
  }
  showRangeTooltips() {
    var i, s;
    if (!this.withTooltip) return;
    const e = (i = this.shadowRoot) == null ? void 0 : i.getElementById("tooltip-thumb-min"), t = (s = this.shadowRoot) == null ? void 0 : s.getElementById("tooltip-thumb-max");
    this.activeThumb === "min" ? (e && (e.open = !0), t && (t.open = !1)) : this.activeThumb === "max" && (t && (t.open = !0), e && (e.open = !1));
  }
  hideRangeTooltips() {
    var i, s;
    if (!this.withTooltip) return;
    const e = (i = this.shadowRoot) == null ? void 0 : i.getElementById("tooltip-thumb-min"), t = (s = this.shadowRoot) == null ? void 0 : s.getElementById("tooltip-thumb-max");
    e && (e.open = !1), t && (t.open = !1);
  }
  /** Updates the form value submission for range sliders */
  updateFormValue() {
    if (this.isRange) {
      const e = new FormData();
      e.append(this.name || "", String(this.minValue)), e.append(this.name || "", String(this.maxValue)), this.setValue(e);
    }
  }
  /** Sets focus to the slider. */
  focus() {
    var e;
    this.isRange ? (e = this.thumbMin) == null || e.focus() : this.slider.focus();
  }
  /** Removes focus from the slider. */
  blur() {
    this.isRange ? document.activeElement === this.thumbMin ? this.thumbMin.blur() : document.activeElement === this.thumbMax && this.thumbMax.blur() : this.slider.blur();
  }
  /**
   * Decreases the slider's value by `step`. This is a programmatic change, so `input` and `change` events will not be
   * emitted when this is called.
   */
  stepDown() {
    if (this.isRange) {
      const e = this.clampAndRoundToStep(this.minValue - this.step);
      this.minValue = R(e, this.min, this.maxValue), this.updateFormValue();
    } else {
      const e = this.clampAndRoundToStep(this.value - this.step);
      this.value = e;
    }
  }
  /**
   * Increases the slider's value by `step`. This is a programmatic change, so `input` and `change` events will not be
   * emitted when this is called.
   */
  stepUp() {
    if (this.isRange) {
      const e = this.clampAndRoundToStep(this.maxValue + this.step);
      this.maxValue = R(e, this.minValue, this.max), this.updateFormValue();
    } else {
      const e = this.clampAndRoundToStep(this.value + this.step);
      this.value = e;
    }
  }
  render() {
    const e = this.hasSlotController.test("label"), t = this.hasSlotController.test("hint"), i = this.label ? !0 : !!e, s = this.hint ? !0 : !!t, n = this.hasSlotController.test("reference"), o = gt({
      small: this.size === "small",
      medium: this.size === "medium",
      large: this.size === "large",
      horizontal: this.orientation === "horizontal",
      vertical: this.orientation === "vertical",
      disabled: this.disabled
    }), r = [];
    if (this.withMarkers)
      for (let f = this.min; f <= this.max; f += this.step)
        r.push(this.getPercentageFromValue(f));
    const a = D`
      <label
        id="label"
        part="label"
        for=${this.isRange ? "thumb-min" : "text-box"}
        class=${gt({ vh: !i })}
        @pointerdown=${this.handleLabelPointerDown}
      >
        <slot name="label">${this.label}</slot>
      </label>
    `, l = D`
      <div
        id="hint"
        part="hint"
        class=${gt({
      "has-slotted": s
    })}
      >
        <slot name="hint">${this.hint}</slot>
      </div>
    `, h = this.withMarkers ? D`
          <div id="markers" part="markers">
            ${r.map((f) => D`<span part="marker" class="marker" style="--position: ${f}%"></span>`)}
          </div>
        ` : "", c = n ? D`
          <div id="references" part="references" aria-hidden="true">
            <slot name="reference"></slot>
          </div>
        ` : "", u = (f, d) => this.withTooltip ? D`
            <wa-tooltip
              id=${`tooltip${f !== "thumb" ? "-" + f : ""}`}
              part="tooltip"
              exportparts="
                base:tooltip__base,
                body:tooltip__body,
                arrow:tooltip__arrow
              "
              trigger="manual"
              distance=${this.tooltipDistance}
              placement=${this.tooltipPlacement}
              for=${f}
              activation="manual"
              dir=${this.localize.dir()}
            >
              <span aria-hidden="true">
                ${typeof this.valueFormatter == "function" ? this.valueFormatter(d) : this.localize.number(d)}
              </span>
            </wa-tooltip>
          ` : "";
    if (this.isRange) {
      const f = R(this.getPercentageFromValue(this.minValue), 0, 100), d = R(this.getPercentageFromValue(this.maxValue), 0, 100);
      return D`
        ${a}

        <div id="slider" part="slider" class=${o}>
          <div id="track" part="track">
            <div
              id="indicator"
              part="indicator"
              style="--start: ${Math.min(f, d)}%; --end: ${Math.max(
        f,
        d
      )}%"
            ></div>

            ${h}

            <span
              id="thumb-min"
              part="thumb thumb-min"
              style="--position: ${f}%"
              role="slider"
              aria-valuemin=${this.min}
              aria-valuenow=${this.minValue}
              aria-valuetext=${typeof this.valueFormatter == "function" ? this.valueFormatter(this.minValue) : this.localize.number(this.minValue)}
              aria-valuemax=${this.max}
              aria-label="${this.label ? `${this.label} (minimum value)` : "Minimum value"}"
              aria-orientation=${this.orientation}
              aria-disabled=${this.disabled ? "true" : "false"}
              aria-readonly=${this.readonly ? "true" : "false"}
              tabindex=${this.disabled ? -1 : 0}
              @blur=${this.handleBlur}
              @focus=${this.handleFocus}
              @keydown=${this.handleKeyDown}
            ></span>

            <span
              id="thumb-max"
              part="thumb thumb-max"
              style="--position: ${d}%"
              role="slider"
              aria-valuemin=${this.min}
              aria-valuenow=${this.maxValue}
              aria-valuetext=${typeof this.valueFormatter == "function" ? this.valueFormatter(this.maxValue) : this.localize.number(this.maxValue)}
              aria-valuemax=${this.max}
              aria-label="${this.label ? `${this.label} (maximum value)` : "Maximum value"}"
              aria-orientation=${this.orientation}
              aria-disabled=${this.disabled ? "true" : "false"}
              aria-readonly=${this.readonly ? "true" : "false"}
              tabindex=${this.disabled ? -1 : 0}
              @blur=${this.handleBlur}
              @focus=${this.handleFocus}
              @keydown=${this.handleKeyDown}
            ></span>
          </div>

          ${c} ${l}
        </div>

        ${u("thumb-min", this.minValue)} ${u("thumb-max", this.maxValue)}
      `;
    } else {
      const f = R(this.getPercentageFromValue(this.value), 0, 100), d = R(
        this.getPercentageFromValue(typeof this.indicatorOffset == "number" ? this.indicatorOffset : this.min),
        0,
        100
      );
      return D`
        ${a}

        <div
          id="slider"
          part="slider"
          class=${o}
          role="slider"
          aria-disabled=${this.disabled ? "true" : "false"}
          aria-readonly=${this.disabled ? "true" : "false"}
          aria-orientation=${this.orientation}
          aria-valuemin=${this.min}
          aria-valuenow=${this.value}
          aria-valuetext=${typeof this.valueFormatter == "function" ? this.valueFormatter(this.value) : this.localize.number(this.value)}
          aria-valuemax=${this.max}
          aria-labelledby="label"
          aria-describedby="hint"
          tabindex=${this.disabled ? -1 : 0}
          @blur=${this.handleBlur}
          @focus=${this.handleFocus}
          @keydown=${this.handleKeyDown}
        >
          <div id="track" part="track">
            <div
              id="indicator"
              part="indicator"
              style="--start: ${d}%; --end: ${f}%"
            ></div>

            ${h}
            <span id="thumb" part="thumb" style="--position: ${f}%"></span>
          </div>

          ${c} ${l}
        </div>

        ${u("thumb", this.value)}
      `;
    }
  }
};
y.formAssociated = !0;
y.observeSlots = !0;
y.css = [Qi, Ni, hs];
p([
  N("#slider")
], y.prototype, "slider", 2);
p([
  N("#thumb")
], y.prototype, "thumb", 2);
p([
  N("#thumb-min")
], y.prototype, "thumbMin", 2);
p([
  N("#thumb-max")
], y.prototype, "thumbMax", 2);
p([
  N("#track")
], y.prototype, "track", 2);
p([
  N("#tooltip")
], y.prototype, "tooltip", 2);
p([
  m()
], y.prototype, "label", 2);
p([
  m({ attribute: "hint" })
], y.prototype, "hint", 2);
p([
  m({ reflect: !0 })
], y.prototype, "name", 2);
p([
  m({ type: Number, attribute: "min-value" })
], y.prototype, "minValue", 2);
p([
  m({ type: Number, attribute: "max-value" })
], y.prototype, "maxValue", 2);
p([
  m({ attribute: "value", reflect: !0, type: Number })
], y.prototype, "defaultValue", 2);
p([
  ti()
], y.prototype, "value", 1);
p([
  m({ type: Boolean, reflect: !0 })
], y.prototype, "range", 2);
p([
  m({ type: Boolean })
], y.prototype, "disabled", 2);
p([
  m({ type: Boolean, reflect: !0 })
], y.prototype, "readonly", 2);
p([
  m({ reflect: !0 })
], y.prototype, "orientation", 2);
p([
  m({ reflect: !0 })
], y.prototype, "size", 2);
p([
  m({ attribute: "indicator-offset", type: Number })
], y.prototype, "indicatorOffset", 2);
p([
  m({ reflect: !0 })
], y.prototype, "form", 2);
p([
  m({ type: Number })
], y.prototype, "min", 2);
p([
  m({ type: Number })
], y.prototype, "max", 2);
p([
  m({ type: Number })
], y.prototype, "step", 2);
p([
  m({ type: Boolean, reflect: !0 })
], y.prototype, "required", 2);
p([
  m({ type: Boolean })
], y.prototype, "autofocus", 2);
p([
  m({ attribute: "tooltip-distance", type: Number })
], y.prototype, "tooltipDistance", 2);
p([
  m({ attribute: "tooltip-placement", reflect: !0 })
], y.prototype, "tooltipPlacement", 2);
p([
  m({ attribute: "with-markers", type: Boolean })
], y.prototype, "withMarkers", 2);
p([
  m({ attribute: "with-tooltip", type: Boolean })
], y.prototype, "withTooltip", 2);
p([
  m({ attribute: !1 })
], y.prototype, "valueFormatter", 2);
y = p([
  fe("wa-slider")
], y);
/*! Copyright 2025 Fonticons, Inc. - https://webawesome.com/license */
var cs = class extends Event {
  constructor() {
    super("wa-reposition", { bubbles: !0, cancelable: !1, composed: !0 });
  }
};
const et = Math.min, k = Math.max, Ut = Math.round, Dt = Math.floor, I = (e) => ({
  x: e,
  y: e
}), us = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, ds = {
  start: "end",
  end: "start"
};
function oe(e, t, i) {
  return k(e, et(t, i));
}
function $t(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function it(e) {
  return e.split("-")[0];
}
function Et(e) {
  return e.split("-")[1];
}
function ri(e) {
  return e === "x" ? "y" : "x";
}
function be(e) {
  return e === "y" ? "height" : "width";
}
const ps = /* @__PURE__ */ new Set(["top", "bottom"]);
function Y(e) {
  return ps.has(it(e)) ? "y" : "x";
}
function ve(e) {
  return ri(Y(e));
}
function fs(e, t, i) {
  i === void 0 && (i = !1);
  const s = Et(e), n = ve(e), o = be(n);
  let r = n === "x" ? s === (i ? "end" : "start") ? "right" : "left" : s === "start" ? "bottom" : "top";
  return t.reference[o] > t.floating[o] && (r = Ht(r)), [r, Ht(r)];
}
function ms(e) {
  const t = Ht(e);
  return [re(e), t, re(t)];
}
function re(e) {
  return e.replace(/start|end/g, (t) => ds[t]);
}
const Pe = ["left", "right"], Oe = ["right", "left"], gs = ["top", "bottom"], bs = ["bottom", "top"];
function vs(e, t, i) {
  switch (e) {
    case "top":
    case "bottom":
      return i ? t ? Oe : Pe : t ? Pe : Oe;
    case "left":
    case "right":
      return t ? gs : bs;
    default:
      return [];
  }
}
function ys(e, t, i, s) {
  const n = Et(e);
  let o = vs(it(e), i === "start", s);
  return n && (o = o.map((r) => r + "-" + n), t && (o = o.concat(o.map(re)))), o;
}
function Ht(e) {
  return e.replace(/left|right|bottom|top/g, (t) => us[t]);
}
function ws(e) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...e
  };
}
function ai(e) {
  return typeof e != "number" ? ws(e) : {
    top: e,
    right: e,
    bottom: e,
    left: e
  };
}
function It(e) {
  const {
    x: t,
    y: i,
    width: s,
    height: n
  } = e;
  return {
    width: s,
    height: n,
    top: i,
    left: t,
    right: t + s,
    bottom: i + n,
    x: t,
    y: i
  };
}
function De(e, t, i) {
  let {
    reference: s,
    floating: n
  } = e;
  const o = Y(t), r = ve(t), a = be(r), l = it(t), h = o === "y", c = s.x + s.width / 2 - n.width / 2, u = s.y + s.height / 2 - n.height / 2, f = s[a] / 2 - n[a] / 2;
  let d;
  switch (l) {
    case "top":
      d = {
        x: c,
        y: s.y - n.height
      };
      break;
    case "bottom":
      d = {
        x: c,
        y: s.y + s.height
      };
      break;
    case "right":
      d = {
        x: s.x + s.width,
        y: u
      };
      break;
    case "left":
      d = {
        x: s.x - n.width,
        y: u
      };
      break;
    default:
      d = {
        x: s.x,
        y: s.y
      };
  }
  switch (Et(t)) {
    case "start":
      d[r] -= f * (i && h ? -1 : 1);
      break;
    case "end":
      d[r] += f * (i && h ? -1 : 1);
      break;
  }
  return d;
}
const xs = async (e, t, i) => {
  const {
    placement: s = "bottom",
    strategy: n = "absolute",
    middleware: o = [],
    platform: r
  } = i, a = o.filter(Boolean), l = await (r.isRTL == null ? void 0 : r.isRTL(t));
  let h = await r.getElementRects({
    reference: e,
    floating: t,
    strategy: n
  }), {
    x: c,
    y: u
  } = De(h, s, l), f = s, d = {}, g = 0;
  for (let b = 0; b < a.length; b++) {
    const {
      name: w,
      fn: v
    } = a[b], {
      x,
      y: E,
      data: C,
      reset: A
    } = await v({
      x: c,
      y: u,
      initialPlacement: s,
      placement: f,
      strategy: n,
      middlewareData: d,
      rects: h,
      platform: r,
      elements: {
        reference: e,
        floating: t
      }
    });
    c = x ?? c, u = E ?? u, d = {
      ...d,
      [w]: {
        ...d[w],
        ...C
      }
    }, A && g <= 50 && (g++, typeof A == "object" && (A.placement && (f = A.placement), A.rects && (h = A.rects === !0 ? await r.getElementRects({
      reference: e,
      floating: t,
      strategy: n
    }) : A.rects), {
      x: c,
      y: u
    } = De(h, f, l)), b = -1);
  }
  return {
    x: c,
    y: u,
    placement: f,
    strategy: n,
    middlewareData: d
  };
};
async function ye(e, t) {
  var i;
  t === void 0 && (t = {});
  const {
    x: s,
    y: n,
    platform: o,
    rects: r,
    elements: a,
    strategy: l
  } = e, {
    boundary: h = "clippingAncestors",
    rootBoundary: c = "viewport",
    elementContext: u = "floating",
    altBoundary: f = !1,
    padding: d = 0
  } = $t(t, e), g = ai(d), w = a[f ? u === "floating" ? "reference" : "floating" : u], v = It(await o.getClippingRect({
    element: (i = await (o.isElement == null ? void 0 : o.isElement(w))) == null || i ? w : w.contextElement || await (o.getDocumentElement == null ? void 0 : o.getDocumentElement(a.floating)),
    boundary: h,
    rootBoundary: c,
    strategy: l
  })), x = u === "floating" ? {
    x: s,
    y: n,
    width: r.floating.width,
    height: r.floating.height
  } : r.reference, E = await (o.getOffsetParent == null ? void 0 : o.getOffsetParent(a.floating)), C = await (o.isElement == null ? void 0 : o.isElement(E)) ? await (o.getScale == null ? void 0 : o.getScale(E)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, A = It(o.convertOffsetParentRelativeRectToViewportRelativeRect ? await o.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: a,
    rect: x,
    offsetParent: E,
    strategy: l
  }) : x);
  return {
    top: (v.top - A.top + g.top) / C.y,
    bottom: (A.bottom - v.bottom + g.bottom) / C.y,
    left: (v.left - A.left + g.left) / C.x,
    right: (A.right - v.right + g.right) / C.x
  };
}
const $s = (e) => ({
  name: "arrow",
  options: e,
  async fn(t) {
    const {
      x: i,
      y: s,
      placement: n,
      rects: o,
      platform: r,
      elements: a,
      middlewareData: l
    } = t, {
      element: h,
      padding: c = 0
    } = $t(e, t) || {};
    if (h == null)
      return {};
    const u = ai(c), f = {
      x: i,
      y: s
    }, d = ve(n), g = be(d), b = await r.getDimensions(h), w = d === "y", v = w ? "top" : "left", x = w ? "bottom" : "right", E = w ? "clientHeight" : "clientWidth", C = o.reference[g] + o.reference[d] - f[d] - o.floating[g], A = f[d] - o.reference[d], M = await (r.getOffsetParent == null ? void 0 : r.getOffsetParent(h));
    let T = M ? M[E] : 0;
    (!T || !await (r.isElement == null ? void 0 : r.isElement(M))) && (T = a.floating[E] || o.floating[g]);
    const j = C / 2 - A / 2, U = T / 2 - b[g] / 2 - 1, O = et(u[v], U), Z = et(u[x], U), H = O, G = T - b[g] - Z, V = T / 2 - b[g] / 2 + j, ot = oe(H, V, G), K = !l.arrow && Et(n) != null && V !== ot && o.reference[g] / 2 - (V < H ? O : Z) - b[g] / 2 < 0, L = K ? V < H ? V - H : V - G : 0;
    return {
      [d]: f[d] + L,
      data: {
        [d]: ot,
        centerOffset: V - ot - L,
        ...K && {
          alignmentOffset: L
        }
      },
      reset: K
    };
  }
}), Es = function(e) {
  return e === void 0 && (e = {}), {
    name: "flip",
    options: e,
    async fn(t) {
      var i, s;
      const {
        placement: n,
        middlewareData: o,
        rects: r,
        initialPlacement: a,
        platform: l,
        elements: h
      } = t, {
        mainAxis: c = !0,
        crossAxis: u = !0,
        fallbackPlacements: f,
        fallbackStrategy: d = "bestFit",
        fallbackAxisSideDirection: g = "none",
        flipAlignment: b = !0,
        ...w
      } = $t(e, t);
      if ((i = o.arrow) != null && i.alignmentOffset)
        return {};
      const v = it(n), x = Y(a), E = it(a) === a, C = await (l.isRTL == null ? void 0 : l.isRTL(h.floating)), A = f || (E || !b ? [Ht(a)] : ms(a)), M = g !== "none";
      !f && M && A.push(...ys(a, b, g, C));
      const T = [a, ...A], j = await ye(t, w), U = [];
      let O = ((s = o.flip) == null ? void 0 : s.overflows) || [];
      if (c && U.push(j[v]), u) {
        const V = fs(n, r, C);
        U.push(j[V[0]], j[V[1]]);
      }
      if (O = [...O, {
        placement: n,
        overflows: U
      }], !U.every((V) => V <= 0)) {
        var Z, H;
        const V = (((Z = o.flip) == null ? void 0 : Z.index) || 0) + 1, ot = T[V];
        if (ot && (!(u === "alignment" ? x !== Y(ot) : !1) || // We leave the current main axis only if every placement on that axis
        // overflows the main axis.
        O.every((z) => Y(z.placement) === x ? z.overflows[0] > 0 : !0)))
          return {
            data: {
              index: V,
              overflows: O
            },
            reset: {
              placement: ot
            }
          };
        let K = (H = O.filter((L) => L.overflows[0] <= 0).sort((L, z) => L.overflows[1] - z.overflows[1])[0]) == null ? void 0 : H.placement;
        if (!K)
          switch (d) {
            case "bestFit": {
              var G;
              const L = (G = O.filter((z) => {
                if (M) {
                  const J = Y(z.placement);
                  return J === x || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  J === "y";
                }
                return !0;
              }).map((z) => [z.placement, z.overflows.filter((J) => J > 0).reduce((J, gi) => J + gi, 0)]).sort((z, J) => z[1] - J[1])[0]) == null ? void 0 : G[0];
              L && (K = L);
              break;
            }
            case "initialPlacement":
              K = a;
              break;
          }
        if (n !== K)
          return {
            reset: {
              placement: K
            }
          };
      }
      return {};
    }
  };
}, As = /* @__PURE__ */ new Set(["left", "top"]);
async function Ss(e, t) {
  const {
    placement: i,
    platform: s,
    elements: n
  } = e, o = await (s.isRTL == null ? void 0 : s.isRTL(n.floating)), r = it(i), a = Et(i), l = Y(i) === "y", h = As.has(r) ? -1 : 1, c = o && l ? -1 : 1, u = $t(t, e);
  let {
    mainAxis: f,
    crossAxis: d,
    alignmentAxis: g
  } = typeof u == "number" ? {
    mainAxis: u,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: u.mainAxis || 0,
    crossAxis: u.crossAxis || 0,
    alignmentAxis: u.alignmentAxis
  };
  return a && typeof g == "number" && (d = a === "end" ? g * -1 : g), l ? {
    x: d * c,
    y: f * h
  } : {
    x: f * h,
    y: d * c
  };
}
const Cs = function(e) {
  return e === void 0 && (e = 0), {
    name: "offset",
    options: e,
    async fn(t) {
      var i, s;
      const {
        x: n,
        y: o,
        placement: r,
        middlewareData: a
      } = t, l = await Ss(t, e);
      return r === ((i = a.offset) == null ? void 0 : i.placement) && (s = a.arrow) != null && s.alignmentOffset ? {} : {
        x: n + l.x,
        y: o + l.y,
        data: {
          ...l,
          placement: r
        }
      };
    }
  };
}, _s = function(e) {
  return e === void 0 && (e = {}), {
    name: "shift",
    options: e,
    async fn(t) {
      const {
        x: i,
        y: s,
        placement: n
      } = t, {
        mainAxis: o = !0,
        crossAxis: r = !1,
        limiter: a = {
          fn: (w) => {
            let {
              x: v,
              y: x
            } = w;
            return {
              x: v,
              y: x
            };
          }
        },
        ...l
      } = $t(e, t), h = {
        x: i,
        y: s
      }, c = await ye(t, l), u = Y(it(n)), f = ri(u);
      let d = h[f], g = h[u];
      if (o) {
        const w = f === "y" ? "top" : "left", v = f === "y" ? "bottom" : "right", x = d + c[w], E = d - c[v];
        d = oe(x, d, E);
      }
      if (r) {
        const w = u === "y" ? "top" : "left", v = u === "y" ? "bottom" : "right", x = g + c[w], E = g - c[v];
        g = oe(x, g, E);
      }
      const b = a.fn({
        ...t,
        [f]: d,
        [u]: g
      });
      return {
        ...b,
        data: {
          x: b.x - i,
          y: b.y - s,
          enabled: {
            [f]: o,
            [u]: r
          }
        }
      };
    }
  };
}, Ts = function(e) {
  return e === void 0 && (e = {}), {
    name: "size",
    options: e,
    async fn(t) {
      var i, s;
      const {
        placement: n,
        rects: o,
        platform: r,
        elements: a
      } = t, {
        apply: l = () => {
        },
        ...h
      } = $t(e, t), c = await ye(t, h), u = it(n), f = Et(n), d = Y(n) === "y", {
        width: g,
        height: b
      } = o.floating;
      let w, v;
      u === "top" || u === "bottom" ? (w = u, v = f === (await (r.isRTL == null ? void 0 : r.isRTL(a.floating)) ? "start" : "end") ? "left" : "right") : (v = u, w = f === "end" ? "top" : "bottom");
      const x = b - c.top - c.bottom, E = g - c.left - c.right, C = et(b - c[w], x), A = et(g - c[v], E), M = !t.middlewareData.shift;
      let T = C, j = A;
      if ((i = t.middlewareData.shift) != null && i.enabled.x && (j = E), (s = t.middlewareData.shift) != null && s.enabled.y && (T = x), M && !f) {
        const O = k(c.left, 0), Z = k(c.right, 0), H = k(c.top, 0), G = k(c.bottom, 0);
        d ? j = g - 2 * (O !== 0 || Z !== 0 ? O + Z : k(c.left, c.right)) : T = b - 2 * (H !== 0 || G !== 0 ? H + G : k(c.top, c.bottom));
      }
      await l({
        ...t,
        availableWidth: j,
        availableHeight: T
      });
      const U = await r.getDimensions(a.floating);
      return g !== U.width || b !== U.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function qt() {
  return typeof window < "u";
}
function At(e) {
  return li(e) ? (e.nodeName || "").toLowerCase() : "#document";
}
function P(e) {
  var t;
  return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function q(e) {
  var t;
  return (t = (li(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement;
}
function li(e) {
  return qt() ? e instanceof Node || e instanceof P(e).Node : !1;
}
function F(e) {
  return qt() ? e instanceof Element || e instanceof P(e).Element : !1;
}
function W(e) {
  return qt() ? e instanceof HTMLElement || e instanceof P(e).HTMLElement : !1;
}
function Me(e) {
  return !qt() || typeof ShadowRoot > "u" ? !1 : e instanceof ShadowRoot || e instanceof P(e).ShadowRoot;
}
const Vs = /* @__PURE__ */ new Set(["inline", "contents"]);
function Pt(e) {
  const {
    overflow: t,
    overflowX: i,
    overflowY: s,
    display: n
  } = B(e);
  return /auto|scroll|overlay|hidden|clip/.test(t + s + i) && !Vs.has(n);
}
const Rs = /* @__PURE__ */ new Set(["table", "td", "th"]);
function ks(e) {
  return Rs.has(At(e));
}
const Ps = [":popover-open", ":modal"];
function jt(e) {
  return Ps.some((t) => {
    try {
      return e.matches(t);
    } catch {
      return !1;
    }
  });
}
const Os = ["transform", "translate", "scale", "rotate", "perspective"], Ds = ["transform", "translate", "scale", "rotate", "perspective", "filter"], Ms = ["paint", "layout", "strict", "content"];
function Kt(e) {
  const t = we(), i = F(e) ? B(e) : e;
  return Os.some((s) => i[s] ? i[s] !== "none" : !1) || (i.containerType ? i.containerType !== "normal" : !1) || !t && (i.backdropFilter ? i.backdropFilter !== "none" : !1) || !t && (i.filter ? i.filter !== "none" : !1) || Ds.some((s) => (i.willChange || "").includes(s)) || Ms.some((s) => (i.contain || "").includes(s));
}
function Ls(e) {
  let t = st(e);
  for (; W(t) && !yt(t); ) {
    if (Kt(t))
      return t;
    if (jt(t))
      return null;
    t = st(t);
  }
  return null;
}
function we() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
const zs = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function yt(e) {
  return zs.has(At(e));
}
function B(e) {
  return P(e).getComputedStyle(e);
}
function Xt(e) {
  return F(e) ? {
    scrollLeft: e.scrollLeft,
    scrollTop: e.scrollTop
  } : {
    scrollLeft: e.scrollX,
    scrollTop: e.scrollY
  };
}
function st(e) {
  if (At(e) === "html")
    return e;
  const t = (
    // Step into the shadow DOM of the parent of a slotted node.
    e.assignedSlot || // DOM Element detected.
    e.parentNode || // ShadowRoot detected.
    Me(e) && e.host || // Fallback.
    q(e)
  );
  return Me(t) ? t.host : t;
}
function hi(e) {
  const t = st(e);
  return yt(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : W(t) && Pt(t) ? t : hi(t);
}
function wt(e, t, i) {
  var s;
  t === void 0 && (t = []), i === void 0 && (i = !0);
  const n = hi(e), o = n === ((s = e.ownerDocument) == null ? void 0 : s.body), r = P(n);
  if (o) {
    const a = ae(r);
    return t.concat(r, r.visualViewport || [], Pt(n) ? n : [], a && i ? wt(a) : []);
  }
  return t.concat(n, wt(n, [], i));
}
function ae(e) {
  return e.parent && Object.getPrototypeOf(e.parent) ? e.frameElement : null;
}
function ci(e) {
  const t = B(e);
  let i = parseFloat(t.width) || 0, s = parseFloat(t.height) || 0;
  const n = W(e), o = n ? e.offsetWidth : i, r = n ? e.offsetHeight : s, a = Ut(i) !== o || Ut(s) !== r;
  return a && (i = o, s = r), {
    width: i,
    height: s,
    $: a
  };
}
function xe(e) {
  return F(e) ? e : e.contextElement;
}
function bt(e) {
  const t = xe(e);
  if (!W(t))
    return I(1);
  const i = t.getBoundingClientRect(), {
    width: s,
    height: n,
    $: o
  } = ci(t);
  let r = (o ? Ut(i.width) : i.width) / s, a = (o ? Ut(i.height) : i.height) / n;
  return (!r || !Number.isFinite(r)) && (r = 1), (!a || !Number.isFinite(a)) && (a = 1), {
    x: r,
    y: a
  };
}
const Fs = /* @__PURE__ */ I(0);
function ui(e) {
  const t = P(e);
  return !we() || !t.visualViewport ? Fs : {
    x: t.visualViewport.offsetLeft,
    y: t.visualViewport.offsetTop
  };
}
function Bs(e, t, i) {
  return t === void 0 && (t = !1), !i || t && i !== P(e) ? !1 : t;
}
function dt(e, t, i, s) {
  t === void 0 && (t = !1), i === void 0 && (i = !1);
  const n = e.getBoundingClientRect(), o = xe(e);
  let r = I(1);
  t && (s ? F(s) && (r = bt(s)) : r = bt(e));
  const a = Bs(o, i, s) ? ui(o) : I(0);
  let l = (n.left + a.x) / r.x, h = (n.top + a.y) / r.y, c = n.width / r.x, u = n.height / r.y;
  if (o) {
    const f = P(o), d = s && F(s) ? P(s) : s;
    let g = f, b = ae(g);
    for (; b && s && d !== g; ) {
      const w = bt(b), v = b.getBoundingClientRect(), x = B(b), E = v.left + (b.clientLeft + parseFloat(x.paddingLeft)) * w.x, C = v.top + (b.clientTop + parseFloat(x.paddingTop)) * w.y;
      l *= w.x, h *= w.y, c *= w.x, u *= w.y, l += E, h += C, g = P(b), b = ae(g);
    }
  }
  return It({
    width: c,
    height: u,
    x: l,
    y: h
  });
}
function Yt(e, t) {
  const i = Xt(e).scrollLeft;
  return t ? t.left + i : dt(q(e)).left + i;
}
function di(e, t) {
  const i = e.getBoundingClientRect(), s = i.left + t.scrollLeft - Yt(e, i), n = i.top + t.scrollTop;
  return {
    x: s,
    y: n
  };
}
function Ns(e) {
  let {
    elements: t,
    rect: i,
    offsetParent: s,
    strategy: n
  } = e;
  const o = n === "fixed", r = q(s), a = t ? jt(t.floating) : !1;
  if (s === r || a && o)
    return i;
  let l = {
    scrollLeft: 0,
    scrollTop: 0
  }, h = I(1);
  const c = I(0), u = W(s);
  if ((u || !u && !o) && ((At(s) !== "body" || Pt(r)) && (l = Xt(s)), W(s))) {
    const d = dt(s);
    h = bt(s), c.x = d.x + s.clientLeft, c.y = d.y + s.clientTop;
  }
  const f = r && !u && !o ? di(r, l) : I(0);
  return {
    width: i.width * h.x,
    height: i.height * h.y,
    x: i.x * h.x - l.scrollLeft * h.x + c.x + f.x,
    y: i.y * h.y - l.scrollTop * h.y + c.y + f.y
  };
}
function Us(e) {
  return Array.from(e.getClientRects());
}
function Hs(e) {
  const t = q(e), i = Xt(e), s = e.ownerDocument.body, n = k(t.scrollWidth, t.clientWidth, s.scrollWidth, s.clientWidth), o = k(t.scrollHeight, t.clientHeight, s.scrollHeight, s.clientHeight);
  let r = -i.scrollLeft + Yt(e);
  const a = -i.scrollTop;
  return B(s).direction === "rtl" && (r += k(t.clientWidth, s.clientWidth) - n), {
    width: n,
    height: o,
    x: r,
    y: a
  };
}
const Le = 25;
function Is(e, t) {
  const i = P(e), s = q(e), n = i.visualViewport;
  let o = s.clientWidth, r = s.clientHeight, a = 0, l = 0;
  if (n) {
    o = n.width, r = n.height;
    const c = we();
    (!c || c && t === "fixed") && (a = n.offsetLeft, l = n.offsetTop);
  }
  const h = Yt(s);
  if (h <= 0) {
    const c = s.ownerDocument, u = c.body, f = getComputedStyle(u), d = c.compatMode === "CSS1Compat" && parseFloat(f.marginLeft) + parseFloat(f.marginRight) || 0, g = Math.abs(s.clientWidth - u.clientWidth - d);
    g <= Le && (o -= g);
  } else h <= Le && (o += h);
  return {
    width: o,
    height: r,
    x: a,
    y: l
  };
}
const Ws = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function qs(e, t) {
  const i = dt(e, !0, t === "fixed"), s = i.top + e.clientTop, n = i.left + e.clientLeft, o = W(e) ? bt(e) : I(1), r = e.clientWidth * o.x, a = e.clientHeight * o.y, l = n * o.x, h = s * o.y;
  return {
    width: r,
    height: a,
    x: l,
    y: h
  };
}
function ze(e, t, i) {
  let s;
  if (t === "viewport")
    s = Is(e, i);
  else if (t === "document")
    s = Hs(q(e));
  else if (F(t))
    s = qs(t, i);
  else {
    const n = ui(e);
    s = {
      x: t.x - n.x,
      y: t.y - n.y,
      width: t.width,
      height: t.height
    };
  }
  return It(s);
}
function pi(e, t) {
  const i = st(e);
  return i === t || !F(i) || yt(i) ? !1 : B(i).position === "fixed" || pi(i, t);
}
function js(e, t) {
  const i = t.get(e);
  if (i)
    return i;
  let s = wt(e, [], !1).filter((a) => F(a) && At(a) !== "body"), n = null;
  const o = B(e).position === "fixed";
  let r = o ? st(e) : e;
  for (; F(r) && !yt(r); ) {
    const a = B(r), l = Kt(r);
    !l && a.position === "fixed" && (n = null), (o ? !l && !n : !l && a.position === "static" && !!n && Ws.has(n.position) || Pt(r) && !l && pi(e, r)) ? s = s.filter((c) => c !== r) : n = a, r = st(r);
  }
  return t.set(e, s), s;
}
function Ks(e) {
  let {
    element: t,
    boundary: i,
    rootBoundary: s,
    strategy: n
  } = e;
  const r = [...i === "clippingAncestors" ? jt(t) ? [] : js(t, this._c) : [].concat(i), s], a = r[0], l = r.reduce((h, c) => {
    const u = ze(t, c, n);
    return h.top = k(u.top, h.top), h.right = et(u.right, h.right), h.bottom = et(u.bottom, h.bottom), h.left = k(u.left, h.left), h;
  }, ze(t, a, n));
  return {
    width: l.right - l.left,
    height: l.bottom - l.top,
    x: l.left,
    y: l.top
  };
}
function Xs(e) {
  const {
    width: t,
    height: i
  } = ci(e);
  return {
    width: t,
    height: i
  };
}
function Ys(e, t, i) {
  const s = W(t), n = q(t), o = i === "fixed", r = dt(e, !0, o, t);
  let a = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const l = I(0);
  function h() {
    l.x = Yt(n);
  }
  if (s || !s && !o)
    if ((At(t) !== "body" || Pt(n)) && (a = Xt(t)), s) {
      const d = dt(t, !0, o, t);
      l.x = d.x + t.clientLeft, l.y = d.y + t.clientTop;
    } else n && h();
  o && !s && n && h();
  const c = n && !s && !o ? di(n, a) : I(0), u = r.left + a.scrollLeft - l.x - c.x, f = r.top + a.scrollTop - l.y - c.y;
  return {
    x: u,
    y: f,
    width: r.width,
    height: r.height
  };
}
function ie(e) {
  return B(e).position === "static";
}
function Fe(e, t) {
  if (!W(e) || B(e).position === "fixed")
    return null;
  if (t)
    return t(e);
  let i = e.offsetParent;
  return q(e) === i && (i = i.ownerDocument.body), i;
}
function fi(e, t) {
  const i = P(e);
  if (jt(e))
    return i;
  if (!W(e)) {
    let n = st(e);
    for (; n && !yt(n); ) {
      if (F(n) && !ie(n))
        return n;
      n = st(n);
    }
    return i;
  }
  let s = Fe(e, t);
  for (; s && ks(s) && ie(s); )
    s = Fe(s, t);
  return s && yt(s) && ie(s) && !Kt(s) ? i : s || Ls(e) || i;
}
const Zs = async function(e) {
  const t = this.getOffsetParent || fi, i = this.getDimensions, s = await i(e.floating);
  return {
    reference: Ys(e.reference, await t(e.floating), e.strategy),
    floating: {
      x: 0,
      y: 0,
      width: s.width,
      height: s.height
    }
  };
};
function Gs(e) {
  return B(e).direction === "rtl";
}
const Ft = {
  convertOffsetParentRelativeRectToViewportRelativeRect: Ns,
  getDocumentElement: q,
  getClippingRect: Ks,
  getOffsetParent: fi,
  getElementRects: Zs,
  getClientRects: Us,
  getDimensions: Xs,
  getScale: bt,
  isElement: F,
  isRTL: Gs
};
function mi(e, t) {
  return e.x === t.x && e.y === t.y && e.width === t.width && e.height === t.height;
}
function Js(e, t) {
  let i = null, s;
  const n = q(e);
  function o() {
    var a;
    clearTimeout(s), (a = i) == null || a.disconnect(), i = null;
  }
  function r(a, l) {
    a === void 0 && (a = !1), l === void 0 && (l = 1), o();
    const h = e.getBoundingClientRect(), {
      left: c,
      top: u,
      width: f,
      height: d
    } = h;
    if (a || t(), !f || !d)
      return;
    const g = Dt(u), b = Dt(n.clientWidth - (c + f)), w = Dt(n.clientHeight - (u + d)), v = Dt(c), E = {
      rootMargin: -g + "px " + -b + "px " + -w + "px " + -v + "px",
      threshold: k(0, et(1, l)) || 1
    };
    let C = !0;
    function A(M) {
      const T = M[0].intersectionRatio;
      if (T !== l) {
        if (!C)
          return r();
        T ? r(!1, T) : s = setTimeout(() => {
          r(!1, 1e-7);
        }, 1e3);
      }
      T === 1 && !mi(h, e.getBoundingClientRect()) && r(), C = !1;
    }
    try {
      i = new IntersectionObserver(A, {
        ...E,
        // Handle <iframe>s
        root: n.ownerDocument
      });
    } catch {
      i = new IntersectionObserver(A, E);
    }
    i.observe(e);
  }
  return r(!0), o;
}
function Qs(e, t, i, s) {
  s === void 0 && (s = {});
  const {
    ancestorScroll: n = !0,
    ancestorResize: o = !0,
    elementResize: r = typeof ResizeObserver == "function",
    layoutShift: a = typeof IntersectionObserver == "function",
    animationFrame: l = !1
  } = s, h = xe(e), c = n || o ? [...h ? wt(h) : [], ...wt(t)] : [];
  c.forEach((v) => {
    n && v.addEventListener("scroll", i, {
      passive: !0
    }), o && v.addEventListener("resize", i);
  });
  const u = h && a ? Js(h, i) : null;
  let f = -1, d = null;
  r && (d = new ResizeObserver((v) => {
    let [x] = v;
    x && x.target === h && d && (d.unobserve(t), cancelAnimationFrame(f), f = requestAnimationFrame(() => {
      var E;
      (E = d) == null || E.observe(t);
    })), i();
  }), h && !l && d.observe(h), d.observe(t));
  let g, b = l ? dt(e) : null;
  l && w();
  function w() {
    const v = dt(e);
    b && !mi(b, v) && i(), b = v, g = requestAnimationFrame(w);
  }
  return i(), () => {
    var v;
    c.forEach((x) => {
      n && x.removeEventListener("scroll", i), o && x.removeEventListener("resize", i);
    }), u == null || u(), (v = d) == null || v.disconnect(), d = null, l && cancelAnimationFrame(g);
  };
}
const tn = Cs, en = _s, sn = Es, Be = Ts, nn = $s, on = (e, t, i) => {
  const s = /* @__PURE__ */ new Map(), n = {
    platform: Ft,
    ...i
  }, o = {
    ...n.platform,
    _c: s
  };
  return xs(e, t, {
    ...n,
    platform: o
  });
};
function rn(e) {
  return an(e);
}
function se(e) {
  return e.assignedSlot ? e.assignedSlot : e.parentNode instanceof ShadowRoot ? e.parentNode.host : e.parentNode;
}
function an(e) {
  for (let t = e; t; t = se(t)) if (t instanceof Element && getComputedStyle(t).display === "none") return null;
  for (let t = se(e); t; t = se(t)) {
    if (!(t instanceof Element)) continue;
    const i = getComputedStyle(t);
    if (i.display !== "contents" && (i.position !== "static" || Kt(i) || t.tagName === "BODY"))
      return t;
  }
  return null;
}
/*! Copyright 2025 Fonticons, Inc. - https://webawesome.com/license */
var ln = `:host {
  --arrow-color: black;
  --arrow-size: var(--wa-tooltip-arrow-size);
  --show-duration: 100ms;
  --hide-duration: 100ms;

  /*
     * These properties are computed to account for the arrow's dimensions after being rotated 45. The constant
     * 0.7071 is derived from sin(45), which is the diagonal size of the arrow's container after rotating.
     */
  --arrow-size-diagonal: calc(var(--arrow-size) * 0.7071);
  --arrow-padding-offset: calc(var(--arrow-size-diagonal) - var(--arrow-size));

  display: contents;
}

.popup {
  position: absolute;
  isolation: isolate;
  max-width: var(--auto-size-available-width, none);
  max-height: var(--auto-size-available-height, none);

  /* Clear UA styles for [popover] */
  :where(&) {
    inset: unset;
    padding: unset;
    margin: unset;
    width: unset;
    height: unset;
    color: unset;
    background: unset;
    border: unset;
    overflow: unset;
  }
}

.popup-fixed {
  position: fixed;
}

.popup:not(.popup-active) {
  display: none;
}

.arrow {
  position: absolute;
  width: calc(var(--arrow-size-diagonal) * 2);
  height: calc(var(--arrow-size-diagonal) * 2);
  rotate: 45deg;
  background: var(--arrow-color);
  z-index: 3;
}

:host([data-current-placement~='left']) .arrow {
  rotate: -45deg;
}

:host([data-current-placement~='right']) .arrow {
  rotate: 135deg;
}

:host([data-current-placement~='bottom']) .arrow {
  rotate: 225deg;
}

/* Hover bridge */
.popup-hover-bridge:not(.popup-hover-bridge-visible) {
  display: none;
}

.popup-hover-bridge {
  position: fixed;
  z-index: 899;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  clip-path: polygon(
    var(--hover-bridge-top-left-x, 0) var(--hover-bridge-top-left-y, 0),
    var(--hover-bridge-top-right-x, 0) var(--hover-bridge-top-right-y, 0),
    var(--hover-bridge-bottom-right-x, 0) var(--hover-bridge-bottom-right-y, 0),
    var(--hover-bridge-bottom-left-x, 0) var(--hover-bridge-bottom-left-y, 0)
  );
}

/* Built-in animations */
.show {
  animation: show var(--show-duration) ease;
}

.hide {
  animation: show var(--hide-duration) ease reverse;
}

@keyframes show {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}

.show-with-scale {
  animation: show-with-scale var(--show-duration) ease;
}

.hide-with-scale {
  animation: show-with-scale var(--hide-duration) ease reverse;
}

@keyframes show-with-scale {
  from {
    opacity: 0;
    scale: 0.8;
  }
  to {
    opacity: 1;
    scale: 1;
  }
}
`;
function Ne(e) {
  return e !== null && typeof e == "object" && "getBoundingClientRect" in e && ("contextElement" in e ? e instanceof Element : !0);
}
var qe, Mt = (qe = globalThis == null ? void 0 : globalThis.HTMLElement) == null ? void 0 : qe.prototype.hasOwnProperty("popover"), $ = class extends xt {
  constructor() {
    super(...arguments), this.localize = new oi(this), this.active = !1, this.placement = "top", this.boundary = "viewport", this.distance = 0, this.skidding = 0, this.arrow = !1, this.arrowPlacement = "anchor", this.arrowPadding = 10, this.flip = !1, this.flipFallbackPlacements = "", this.flipFallbackStrategy = "best-fit", this.flipPadding = 0, this.shift = !1, this.shiftPadding = 0, this.autoSizePadding = 0, this.hoverBridge = !1, this.updateHoverBridge = () => {
      if (this.hoverBridge && this.anchorEl) {
        const e = this.anchorEl.getBoundingClientRect(), t = this.popup.getBoundingClientRect(), i = this.placement.includes("top") || this.placement.includes("bottom");
        let s = 0, n = 0, o = 0, r = 0, a = 0, l = 0, h = 0, c = 0;
        i ? e.top < t.top ? (s = e.left, n = e.bottom, o = e.right, r = e.bottom, a = t.left, l = t.top, h = t.right, c = t.top) : (s = t.left, n = t.bottom, o = t.right, r = t.bottom, a = e.left, l = e.top, h = e.right, c = e.top) : e.left < t.left ? (s = e.right, n = e.top, o = t.left, r = t.top, a = e.right, l = e.bottom, h = t.left, c = t.bottom) : (s = t.right, n = t.top, o = e.left, r = e.top, a = t.right, l = t.bottom, h = e.left, c = e.bottom), this.style.setProperty("--hover-bridge-top-left-x", `${s}px`), this.style.setProperty("--hover-bridge-top-left-y", `${n}px`), this.style.setProperty("--hover-bridge-top-right-x", `${o}px`), this.style.setProperty("--hover-bridge-top-right-y", `${r}px`), this.style.setProperty("--hover-bridge-bottom-left-x", `${a}px`), this.style.setProperty("--hover-bridge-bottom-left-y", `${l}px`), this.style.setProperty("--hover-bridge-bottom-right-x", `${h}px`), this.style.setProperty("--hover-bridge-bottom-right-y", `${c}px`);
      }
    };
  }
  async connectedCallback() {
    super.connectedCallback(), await this.updateComplete, this.start();
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.stop();
  }
  async updated(e) {
    super.updated(e), e.has("active") && (this.active ? this.start() : this.stop()), e.has("anchor") && this.handleAnchorChange(), this.active && (await this.updateComplete, this.reposition());
  }
  async handleAnchorChange() {
    if (await this.stop(), this.anchor && typeof this.anchor == "string") {
      const e = this.getRootNode();
      this.anchorEl = e.getElementById(this.anchor);
    } else this.anchor instanceof Element || Ne(this.anchor) ? this.anchorEl = this.anchor : this.anchorEl = this.querySelector('[slot="anchor"]');
    this.anchorEl instanceof HTMLSlotElement && (this.anchorEl = this.anchorEl.assignedElements({ flatten: !0 })[0]), this.anchorEl && this.start();
  }
  start() {
    var e, t;
    !this.anchorEl || !this.active || ((t = (e = this.popup).showPopover) == null || t.call(e), this.cleanup = Qs(this.anchorEl, this.popup, () => {
      this.reposition();
    }));
  }
  async stop() {
    return new Promise((e) => {
      var t, i;
      (i = (t = this.popup).hidePopover) == null || i.call(t), this.cleanup ? (this.cleanup(), this.cleanup = void 0, this.removeAttribute("data-current-placement"), this.style.removeProperty("--auto-size-available-width"), this.style.removeProperty("--auto-size-available-height"), requestAnimationFrame(() => e())) : e();
    });
  }
  /** Forces the popup to recalculate and reposition itself. */
  reposition() {
    if (!this.active || !this.anchorEl)
      return;
    const e = [
      // The offset middleware goes first
      tn({ mainAxis: this.distance, crossAxis: this.skidding })
    ];
    this.sync ? e.push(
      Be({
        apply: ({ rects: s }) => {
          const n = this.sync === "width" || this.sync === "both", o = this.sync === "height" || this.sync === "both";
          this.popup.style.width = n ? `${s.reference.width}px` : "", this.popup.style.height = o ? `${s.reference.height}px` : "";
        }
      })
    ) : (this.popup.style.width = "", this.popup.style.height = "");
    let t;
    Mt && !Ne(this.anchor) && this.boundary === "scroll" && (t = wt(this.anchorEl).filter((s) => s instanceof Element)), this.flip && e.push(
      sn({
        boundary: this.flipBoundary || t,
        // @ts-expect-error - We're converting a string attribute to an array here
        fallbackPlacements: this.flipFallbackPlacements,
        fallbackStrategy: this.flipFallbackStrategy === "best-fit" ? "bestFit" : "initialPlacement",
        padding: this.flipPadding
      })
    ), this.shift && e.push(
      en({
        boundary: this.shiftBoundary || t,
        padding: this.shiftPadding
      })
    ), this.autoSize ? e.push(
      Be({
        boundary: this.autoSizeBoundary || t,
        padding: this.autoSizePadding,
        apply: ({ availableWidth: s, availableHeight: n }) => {
          this.autoSize === "vertical" || this.autoSize === "both" ? this.style.setProperty("--auto-size-available-height", `${n}px`) : this.style.removeProperty("--auto-size-available-height"), this.autoSize === "horizontal" || this.autoSize === "both" ? this.style.setProperty("--auto-size-available-width", `${s}px`) : this.style.removeProperty("--auto-size-available-width");
        }
      })
    ) : (this.style.removeProperty("--auto-size-available-width"), this.style.removeProperty("--auto-size-available-height")), this.arrow && e.push(
      nn({
        element: this.arrowEl,
        padding: this.arrowPadding
      })
    );
    const i = Mt ? (s) => Ft.getOffsetParent(s, rn) : Ft.getOffsetParent;
    on(this.anchorEl, this.popup, {
      placement: this.placement,
      middleware: e,
      strategy: Mt ? "absolute" : "fixed",
      platform: {
        ...Ft,
        getOffsetParent: i
      }
    }).then(({ x: s, y: n, middlewareData: o, placement: r }) => {
      const a = this.localize.dir() === "rtl", l = { top: "bottom", right: "left", bottom: "top", left: "right" }[r.split("-")[0]];
      if (this.setAttribute("data-current-placement", r), Object.assign(this.popup.style, {
        left: `${s}px`,
        top: `${n}px`
      }), this.arrow) {
        const h = o.arrow.x, c = o.arrow.y;
        let u = "", f = "", d = "", g = "";
        if (this.arrowPlacement === "start") {
          const b = typeof h == "number" ? `calc(${this.arrowPadding}px - var(--arrow-padding-offset))` : "";
          u = typeof c == "number" ? `calc(${this.arrowPadding}px - var(--arrow-padding-offset))` : "", f = a ? b : "", g = a ? "" : b;
        } else if (this.arrowPlacement === "end") {
          const b = typeof h == "number" ? `calc(${this.arrowPadding}px - var(--arrow-padding-offset))` : "";
          f = a ? "" : b, g = a ? b : "", d = typeof c == "number" ? `calc(${this.arrowPadding}px - var(--arrow-padding-offset))` : "";
        } else this.arrowPlacement === "center" ? (g = typeof h == "number" ? "calc(50% - var(--arrow-size-diagonal))" : "", u = typeof c == "number" ? "calc(50% - var(--arrow-size-diagonal))" : "") : (g = typeof h == "number" ? `${h}px` : "", u = typeof c == "number" ? `${c}px` : "");
        Object.assign(this.arrowEl.style, {
          top: u,
          right: f,
          bottom: d,
          left: g,
          [l]: "calc(var(--arrow-size-diagonal) * -1)"
        });
      }
    }), requestAnimationFrame(() => this.updateHoverBridge()), this.dispatchEvent(new cs());
  }
  render() {
    return D`
      <slot name="anchor" @slotchange=${this.handleAnchorChange}></slot>

      <span
        part="hover-bridge"
        class=${gt({
      "popup-hover-bridge": !0,
      "popup-hover-bridge-visible": this.hoverBridge && this.active
    })}
      ></span>

      <div
        popover="manual"
        part="popup"
        class=${gt({
      popup: !0,
      "popup-active": this.active,
      "popup-fixed": !Mt,
      "popup-has-arrow": this.arrow
    })}
      >
        <slot></slot>
        ${this.arrow ? D`<div part="arrow" class="arrow" role="presentation"></div>` : ""}
      </div>
    `;
  }
};
$.css = ln;
p([
  N(".popup")
], $.prototype, "popup", 2);
p([
  N(".arrow")
], $.prototype, "arrowEl", 2);
p([
  m()
], $.prototype, "anchor", 2);
p([
  m({ type: Boolean, reflect: !0 })
], $.prototype, "active", 2);
p([
  m({ reflect: !0 })
], $.prototype, "placement", 2);
p([
  m()
], $.prototype, "boundary", 2);
p([
  m({ type: Number })
], $.prototype, "distance", 2);
p([
  m({ type: Number })
], $.prototype, "skidding", 2);
p([
  m({ type: Boolean })
], $.prototype, "arrow", 2);
p([
  m({ attribute: "arrow-placement" })
], $.prototype, "arrowPlacement", 2);
p([
  m({ attribute: "arrow-padding", type: Number })
], $.prototype, "arrowPadding", 2);
p([
  m({ type: Boolean })
], $.prototype, "flip", 2);
p([
  m({
    attribute: "flip-fallback-placements",
    converter: {
      fromAttribute: (e) => e.split(" ").map((t) => t.trim()).filter((t) => t !== ""),
      toAttribute: (e) => e.join(" ")
    }
  })
], $.prototype, "flipFallbackPlacements", 2);
p([
  m({ attribute: "flip-fallback-strategy" })
], $.prototype, "flipFallbackStrategy", 2);
p([
  m({ type: Object })
], $.prototype, "flipBoundary", 2);
p([
  m({ attribute: "flip-padding", type: Number })
], $.prototype, "flipPadding", 2);
p([
  m({ type: Boolean })
], $.prototype, "shift", 2);
p([
  m({ type: Object })
], $.prototype, "shiftBoundary", 2);
p([
  m({ attribute: "shift-padding", type: Number })
], $.prototype, "shiftPadding", 2);
p([
  m({ attribute: "auto-size" })
], $.prototype, "autoSize", 2);
p([
  m()
], $.prototype, "sync", 2);
p([
  m({ type: Object })
], $.prototype, "autoSizeBoundary", 2);
p([
  m({ attribute: "auto-size-padding", type: Number })
], $.prototype, "autoSizePadding", 2);
p([
  m({ attribute: "hover-bridge", type: Boolean })
], $.prototype, "hoverBridge", 2);
$ = p([
  fe("wa-popup")
], $);
/*! Copyright 2025 Fonticons, Inc. - https://webawesome.com/license */
var hn = class extends Event {
  constructor() {
    super("wa-after-hide", { bubbles: !0, cancelable: !1, composed: !0 });
  }
}, cn = class extends Event {
  constructor() {
    super("wa-after-show", { bubbles: !0, cancelable: !1, composed: !0 });
  }
}, un = class extends Event {
  constructor(e) {
    super("wa-hide", { bubbles: !0, cancelable: !0, composed: !0 }), this.detail = e;
  }
}, dn = class extends Event {
  constructor() {
    super("wa-show", { bubbles: !0, cancelable: !0, composed: !0 });
  }
};
/*! Copyright 2025 Fonticons, Inc. - https://webawesome.com/license */
function Ue(e, t) {
  return new Promise((i) => {
    function s(n) {
      n.target === e && (e.removeEventListener(t, s), i());
    }
    e.addEventListener(t, s);
  });
}
/*! Copyright 2025 Fonticons, Inc. - https://webawesome.com/license */
function He(e, t) {
  return new Promise((i) => {
    const s = new AbortController(), { signal: n } = s;
    if (e.classList.contains(t))
      return;
    e.classList.remove(t), e.classList.add(t);
    let o = () => {
      e.classList.remove(t), i(), s.abort();
    };
    e.addEventListener("animationend", o, { once: !0, signal: n }), e.addEventListener("animationcancel", o, { once: !0, signal: n });
  });
}
/*! Copyright 2025 Fonticons, Inc. - https://webawesome.com/license */
function Zt(e, t) {
  const i = {
    waitUntilFirstUpdate: !1,
    ...t
  };
  return (s, n) => {
    const { update: o } = s, r = Array.isArray(e) ? e : [e];
    s.update = function(a) {
      r.forEach((l) => {
        const h = l;
        if (a.has(h)) {
          const c = a.get(h), u = this[h];
          c !== u && (!i.waitUntilFirstUpdate || this.hasUpdated) && this[n](c, u);
        }
      }), o.call(this, a);
    };
  };
}
/*! Copyright 2025 Fonticons, Inc. - https://webawesome.com/license */
var pn = `:host {
  --max-width: 30ch;

  /** These styles are added so we don't interfere in the DOM. */
  display: inline-block;
  position: absolute;

  /** Defaults for inherited CSS properties */
  color: var(--wa-tooltip-content-color);
  font-size: var(--wa-tooltip-font-size);
  line-height: var(--wa-tooltip-line-height);
  text-align: start;
  white-space: normal;
}

.tooltip {
  --arrow-size: var(--wa-tooltip-arrow-size);
  --arrow-color: var(--wa-tooltip-background-color);
}

.tooltip::part(popup) {
  z-index: 1000;
}

.tooltip[placement^='top']::part(popup) {
  transform-origin: bottom;
}

.tooltip[placement^='bottom']::part(popup) {
  transform-origin: top;
}

.tooltip[placement^='left']::part(popup) {
  transform-origin: right;
}

.tooltip[placement^='right']::part(popup) {
  transform-origin: left;
}

.body {
  display: block;
  width: max-content;
  max-width: var(--max-width);
  border-radius: var(--wa-tooltip-border-radius);
  background-color: var(--wa-tooltip-background-color);
  border: var(--wa-tooltip-border-width) var(--wa-tooltip-border-style) var(--wa-tooltip-border-color);
  padding: 0.25em 0.5em;
  user-select: none;
  -webkit-user-select: none;
}

.tooltip::part(arrow) {
  border-bottom: var(--wa-tooltip-border-width) var(--wa-tooltip-border-style) var(--wa-tooltip-border-color);
  border-right: var(--wa-tooltip-border-width) var(--wa-tooltip-border-style) var(--wa-tooltip-border-color);
}
`, S = class extends xt {
  constructor() {
    super(...arguments), this.placement = "top", this.disabled = !1, this.distance = 8, this.open = !1, this.skidding = 0, this.showDelay = 150, this.hideDelay = 0, this.trigger = "hover focus", this.withoutArrow = !1, this.for = null, this.anchor = null, this.eventController = new AbortController(), this.handleBlur = () => {
      this.hasTrigger("focus") && this.hide();
    }, this.handleClick = () => {
      this.hasTrigger("click") && (this.open ? this.hide() : this.show());
    }, this.handleFocus = () => {
      this.hasTrigger("focus") && this.show();
    }, this.handleDocumentKeyDown = (e) => {
      e.key === "Escape" && (e.stopPropagation(), this.hide());
    }, this.handleMouseOver = () => {
      this.hasTrigger("hover") && (clearTimeout(this.hoverTimeout), this.hoverTimeout = window.setTimeout(() => this.show(), this.showDelay));
    }, this.handleMouseOut = () => {
      this.hasTrigger("hover") && (clearTimeout(this.hoverTimeout), this.hoverTimeout = window.setTimeout(() => this.hide(), this.hideDelay));
    };
  }
  connectedCallback() {
    super.connectedCallback(), this.eventController.signal.aborted && (this.eventController = new AbortController()), this.open && (this.open = !1, this.updateComplete.then(() => {
      this.open = !0;
    })), this.id || (this.id = is("wa-tooltip-")), this.for && this.anchor ? (this.anchor = null, this.handleForChange()) : this.for && this.handleForChange();
  }
  disconnectedCallback() {
    super.disconnectedCallback(), document.removeEventListener("keydown", this.handleDocumentKeyDown), this.eventController.abort(), this.anchor && this.removeFromAriaLabelledBy(this.anchor, this.id);
  }
  firstUpdated() {
    this.body.hidden = !this.open, this.open && (this.popup.active = !0, this.popup.reposition());
  }
  hasTrigger(e) {
    return this.trigger.split(" ").includes(e);
  }
  /** Adds the tooltip ID to the aria-labelledby attribute */
  addToAriaLabelledBy(e, t) {
    const s = (e.getAttribute("aria-labelledby") || "").split(/\s+/).filter(Boolean);
    s.includes(t) || (s.push(t), e.setAttribute("aria-labelledby", s.join(" ")));
  }
  /** Removes the tooltip ID from the aria-labelledby attribute */
  removeFromAriaLabelledBy(e, t) {
    const n = (e.getAttribute("aria-labelledby") || "").split(/\s+/).filter(Boolean).filter((o) => o !== t);
    n.length > 0 ? e.setAttribute("aria-labelledby", n.join(" ")) : e.removeAttribute("aria-labelledby");
  }
  async handleOpenChange() {
    if (this.open) {
      if (this.disabled)
        return;
      const e = new dn();
      if (this.dispatchEvent(e), e.defaultPrevented) {
        this.open = !1;
        return;
      }
      document.addEventListener("keydown", this.handleDocumentKeyDown, { signal: this.eventController.signal }), this.body.hidden = !1, this.popup.active = !0, await He(this.popup.popup, "show-with-scale"), this.popup.reposition(), this.dispatchEvent(new cn());
    } else {
      const e = new un();
      if (this.dispatchEvent(e), e.defaultPrevented) {
        this.open = !1;
        return;
      }
      document.removeEventListener("keydown", this.handleDocumentKeyDown), await He(this.popup.popup, "hide-with-scale"), this.popup.active = !1, this.body.hidden = !0, this.dispatchEvent(new hn());
    }
  }
  handleForChange() {
    const e = this.getRootNode();
    if (!e)
      return;
    const t = this.for ? e.getElementById(this.for) : null, i = this.anchor;
    if (t === i)
      return;
    const { signal: s } = this.eventController;
    t && (this.addToAriaLabelledBy(t, this.id), t.addEventListener("blur", this.handleBlur, { capture: !0, signal: s }), t.addEventListener("focus", this.handleFocus, { capture: !0, signal: s }), t.addEventListener("click", this.handleClick, { signal: s }), t.addEventListener("mouseover", this.handleMouseOver, { signal: s }), t.addEventListener("mouseout", this.handleMouseOut, { signal: s })), i && (this.removeFromAriaLabelledBy(i, this.id), i.removeEventListener("blur", this.handleBlur, { capture: !0 }), i.removeEventListener("focus", this.handleFocus, { capture: !0 }), i.removeEventListener("click", this.handleClick), i.removeEventListener("mouseover", this.handleMouseOver), i.removeEventListener("mouseout", this.handleMouseOut)), this.anchor = t;
  }
  async handleOptionsChange() {
    this.hasUpdated && (await this.updateComplete, this.popup.reposition());
  }
  handleDisabledChange() {
    this.disabled && this.open && this.hide();
  }
  /** Shows the tooltip. */
  async show() {
    if (!this.open)
      return this.open = !0, Ue(this, "wa-after-show");
  }
  /** Hides the tooltip */
  async hide() {
    if (this.open)
      return this.open = !1, Ue(this, "wa-after-hide");
  }
  render() {
    return D`
      <wa-popup
        part="base"
        exportparts="
          popup:base__popup,
          arrow:base__arrow
        "
        class=${gt({
      tooltip: !0,
      "tooltip-open": this.open
    })}
        placement=${this.placement}
        distance=${this.distance}
        skidding=${this.skidding}
        flip
        shift
        ?arrow=${!this.withoutArrow}
        hover-bridge
        .anchor=${this.anchor}
      >
        <div part="body" class="body">
          <slot></slot>
        </div>
      </wa-popup>
    `;
  }
};
S.css = pn;
S.dependencies = { "wa-popup": $ };
p([
  N("slot:not([name])")
], S.prototype, "defaultSlot", 2);
p([
  N(".body")
], S.prototype, "body", 2);
p([
  N("wa-popup")
], S.prototype, "popup", 2);
p([
  m()
], S.prototype, "placement", 2);
p([
  m({ type: Boolean, reflect: !0 })
], S.prototype, "disabled", 2);
p([
  m({ type: Number })
], S.prototype, "distance", 2);
p([
  m({ type: Boolean, reflect: !0 })
], S.prototype, "open", 2);
p([
  m({ type: Number })
], S.prototype, "skidding", 2);
p([
  m({ attribute: "show-delay", type: Number })
], S.prototype, "showDelay", 2);
p([
  m({ attribute: "hide-delay", type: Number })
], S.prototype, "hideDelay", 2);
p([
  m()
], S.prototype, "trigger", 2);
p([
  m({ attribute: "without-arrow", type: Boolean, reflect: !0 })
], S.prototype, "withoutArrow", 2);
p([
  m()
], S.prototype, "for", 2);
p([
  ti()
], S.prototype, "anchor", 2);
p([
  Zt("open", { waitUntilFirstUpdate: !0 })
], S.prototype, "handleOpenChange", 1);
p([
  Zt("for")
], S.prototype, "handleForChange", 1);
p([
  Zt(["distance", "placement", "skidding"])
], S.prototype, "handleOptionsChange", 1);
p([
  Zt("disabled")
], S.prototype, "handleDisabledChange", 1);
S = p([
  fe("wa-tooltip")
], S);
const le = new URL(import.meta.url), fn = le.pathname.includes("/src/"), mn = fn ? new URL("/images", le.origin).href : new URL("./images", le).href;
class he extends mt {
  constructor() {
    super(), this.na = 0.2, this.imgUrl = mn;
  }
  getImageUrl() {
    const t = `${this.imgUrl}/chFITC_na${this.na.toFixed(1)}.webp`;
    return console.log("Loading image:", t), t;
  }
  handleSliderChange(t) {
    this.na = parseFloat(t.target.value);
  }
  render() {
    return D`
      <div class="container">
        <div class="controls">
          <wa-slider
            label="Select Image"
            min="0.2"
            max="1.4"
            value="${this.na}"
            step="0.2"
            with-markers
            with-tooltip
            @input="${this.handleSliderChange}"
          >
          </wa-slider>
        </div>
        
        <div class="image-container">
          <img 
            src="${this.getImageUrl()}" 
            loading="lazy"
          >
        </div>
      </div>
    `;
  }
}
Gt(he, "properties", {
  imageIndex: { type: Number },
  imgUrl: { type: String },
  na: { type: Number }
}), Gt(he, "styles", yi`
    :host {
      display: block;
      padding: 20px;
    }
    
    .container {
      display: grid;
      grid-template-columns: 300px 1fr;
      gap: 20px;
      height: 100%;
      max-width: 1200px;
      margin: 0 auto;
    }

    .controls {
      display: flex;
      flex-direction: column;
      gap: 20px;
    }
    
    .image-container {
      display: flex;
      align-items: center;
      justify-content: center;
      background: #f5f5f5;
      border-radius: 8px;
      overflow: hidden;
    }
    
    img {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
    }
  `);
customElements.define("microsim-viewer", he);
function Ie() {
  document.querySelectorAll('[data-component="microsim-viewer"]').forEach((e) => {
    const t = document.createElement("microsim-viewer");
    Object.keys(e.dataset).forEach((i) => {
      t[i] = e.dataset[i];
    }), e.replaceWith(t);
  });
}
document.readyState === "loading" ? document.addEventListener("DOMContentLoaded", Ie) : Ie();
